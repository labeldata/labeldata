{% load static %}
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>라벨 미리보기</title>
  <!-- External Libraries -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700&family=Nanum+Myeongjo:wght@400;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="{% static 'img/favicon.ico' %}">
  <!-- Label Preview CSS -->
  <link href="{% static 'css/label_preview.css' %}?v=20.0" rel="stylesheet">
  <!-- 라벨 상수 로드 -->
  <script src="{% static 'js/label/constants.js' %}"></script>
</head>
<body{% if request.GET.readonly %} class="readonly-mode"{% endif %}>
  <header class="preview-page-header">
    <div style="flex-grow: 1;">
      <h1 class="panel-title">라벨 미리보기</h1>
      <p class="mb-0" style="font-size: 0.75rem; color: #6c757d; margin-top: 4px;">
        {% if request.GET.readonly %}
        저장된 설정으로 라벨을 미리보고 있습니다. 설정을 변경하려면 표시사항 작성 화면에서 수정하세요.
        {% else %}
        표 설정, 텍스트 변환, 분리배출마크를 설정하여 라벨 디자인을 미리 확인하고 PDF로 다운로드하세요
        {% endif %}
      </p>
    </div>
    <div class="preview-actions" role="toolbar" aria-label="미리보기 도구">
      <div class="zoom-controls">
        <button class="btn btn-outline-secondary btn-sm" id="zoomOutBtn" aria-label="축소"><i class="fas fa-search-minus"></i></button>
        <span id="zoomDisplay">100%</span>
        <button class="btn btn-outline-secondary btn-sm" id="zoomInBtn" aria-label="확대"><i class="fas fa-search-plus"></i></button>
      </div>
      {% if not request.GET.readonly %}
      <button class="btn btn-info btn-sm" id="validateButton" aria-label="규정 검증">
        <i class="fas fa-check-circle me-1" aria-hidden="true"></i>규정 검증
      </button>
      {% if is_owner %}
      <button id="saveSettingsBtn" class="btn btn-success btn-sm" aria-label="설정 저장">
        <i class="fas fa-save me-1" aria-hidden="true"></i>설정 저장
      </button>
      {% endif %}
      {% endif %}
      {% if can_upload_pdf %}
      <button class="btn btn-primary btn-sm" id="exportPdfBtn" aria-label="PDF 저장">
        <i class="fas fa-file-arrow-down me-1" aria-hidden="true"></i>PDF 저장
      </button>
      {% endif %}
      {% if not request.GET.readonly and not request.GET.in_tab %}
      <button class="btn btn-secondary btn-sm" onclick="window.close()" aria-label="창 닫기">
        <i class="fas fa-times me-1" aria-hidden="true"></i>닫기
      </button>
      {% endif %}
    </div>
  </header>

  <main class="preview-container">
    <aside class="settings-panel"{% if request.GET.readonly %} style="display: none;"{% endif %}>
      <!-- 탭 네비게이션 -->
      <div class="preview-tabs" style="display: flex; gap: 0.15rem; margin-bottom: 1rem; border-bottom: 2px solid #e9ecef; overflow-x: auto; white-space: nowrap; flex-wrap: nowrap; align-items: center;">
        <button class="preview-tab active" data-tab="table-settings" style="padding: 0.4rem 0.6rem; background: transparent; border: none; border-bottom: 3px solid transparent; color: #6c757d; font-weight: 500; font-size: 0.8rem; cursor: pointer; transition: all 0.2s; flex-shrink: 0;">
          표 설정
        </button>
        <button class="preview-tab" data-tab="field-order" style="padding: 0.4rem 0.6rem; background: transparent; border: none; border-bottom: 3px solid transparent; color: #6c757d; font-weight: 500; font-size: 0.8rem; cursor: pointer; transition: all 0.2s; flex-shrink: 0;">
          항목 순서
        </button>
        <button class="preview-tab" data-tab="text-format" style="padding: 0.4rem 0.6rem; background: transparent; border: none; border-bottom: 3px solid transparent; color: #6c757d; font-weight: 500; font-size: 0.8rem; cursor: pointer; transition: all 0.2s; flex-shrink: 0;">
          텍스트 변환
        </button>
        <button class="preview-tab" data-tab="recycling-mark" style="padding: 0.4rem 0.6rem; background: transparent; border: none; border-bottom: 3px solid transparent; color: #6c757d; font-weight: 500; font-size: 0.8rem; cursor: pointer; transition: all 0.2s; flex-shrink: 0;">
          분리배출마크
        </button>
        <div style="flex: 1;"></div>
        <button class="btn btn-sm btn-outline-secondary" id="resetSettingsBtn" style="border: none; padding: 0.4rem 0.6rem; font-size: 0.9rem;" title="설정 초기화">
          <i class="fas fa-undo"></i>
        </button>
      </div>
      
      <!-- 표 설정 탭 -->
      <section class="preview-tab-content active" id="table-settings-content">
        <div class="alert alert-info" style="border-radius: 8px; background-color: #e7f3ff; border: 1px solid #b3d9ff; padding: 10px; margin-bottom: 0.75rem; font-size: 0.75rem;">
          <i class="fas fa-info-circle"></i> 라벨의 가로 크기, 글꼴, 글자 크기, 자간, 줄간격을 설정합니다. 세로 크기는 자동으로 계산됩니다.
        </div>
        
        <div class="area-info text-primary mb-3" style="font-size: 0.85rem; font-weight: 600;">
          정보표시면 면적: <span id="areaDisplay">100</span> cm²
        </div>
        
        <div class="settings-row-pair">
          <div class="settings-row">
            <label class="form-label required" for="widthInput" style="font-size: 0.85rem; font-weight: 600;">가로 (cm)</label>
            <input type="number" class="form-control form-control-sm" id="widthInput" value="10" min="4" max="50" step="1">
          </div>
          <div class="settings-row">
            <label class="form-label" style="font-size: 0.85rem; font-weight: 600;">세로 (cm) - 자동 계산</label>
            <input type="text" class="form-control form-control-sm" id="heightInput" readonly>
          </div>
        </div>
        <div class="settings-row-pair">
          <div class="settings-row">
            <label class="form-label" for="fontFamilySelect" style="font-size: 0.85rem; font-weight: 600;">글꼴</label>
            <select class="form-select form-select-sm" id="fontFamilySelect">
              <option value="'Noto Sans KR', sans-serif" selected>노토 산스</option>
              <option value="'Nanum Gothic', sans-serif">나눔고딕</option>
              <option value="'Nanum Myeongjo', serif">나눔명조</option>
            </select>
          </div>
          <div class="settings-row">
            <label class="form-label" for="fontSizeInput" style="font-size: 0.85rem; font-weight: 600;">기본 글자 크기 (pt)</label>
            <input type="number" class="form-control form-control-sm" id="fontSizeInput" value="10" min="7" max="72" step="0.5">
          </div>
        </div>
        <div class="settings-row-pair">
          <div class="settings-row">
            <label class="form-label" for="letterSpacingInput" style="font-size: 0.85rem; font-weight: 600;">자간 (%)</label>
            <input type="number" class="form-control form-control-sm" id="letterSpacingInput" value="-5" min="-20" max="20" step="1">
          </div>
          <div class="settings-row">
            <label class="form-label" for="lineHeightInput" style="font-size: 0.85rem; font-weight: 600;">줄간격</label>
            <input type="number" class="form-control form-control-sm" id="lineHeightInput" value="1.5" min="1" max="3.0" step="0.1">
          </div>
        </div>
      </section>
      
      <!-- 항목 순서 탭 -->
      <section class="preview-tab-content" id="field-order-content">
        <div class="alert alert-info" style="border-radius: 8px; background-color: #e7f3ff; border: 1px solid #b3d9ff; padding: 10px; margin-bottom: 0.75rem; font-size: 0.75rem;">
          <i class="fas fa-info-circle"></i> 드래그하여 항목 순서를 변경하고, 눈 아이콘으로 표시/숨김을 전환할 수 있습니다.
        </div>
        
        <!-- 레이아웃 배치 방식 선택 -->
        <div class="mb-3">
          <label class="form-label mb-2" style="font-size: 0.85rem; font-weight: 600;">레이아웃 배치</label>
          <div id="layoutButtonGrid" class="layout-button-grid">
            <button class="layout-btn active" data-layout="vertical">
              <i class="fas fa-bars"></i>
              <span>세로</span>
            </button>
            <button class="layout-btn" data-layout="horizontal">
              <i class="fas fa-columns"></i>
              <span>2단배치</span>
            </button>
            <button class="layout-btn" data-layout="grid">
              <i class="fas fa-th"></i>
              <span>가로형</span>
            </button>
          </div>
        </div>
        
        <p style="font-size: 0.75rem; color: #666; margin-bottom: 0.5rem;">
          드래그 또는 버튼으로 순서 변경, 눈 아이콘으로 표시/숨김
        </p>
        
        <div class="mb-2" style="display: flex; gap: 4px;">
          <button class="btn btn-sm btn-outline-secondary" onclick="resetFieldOrder()" style="flex: 1; font-size: 0.7rem; padding: 0.2rem 0.3rem;">
            <i class="fas fa-undo"></i> 초기화
          </button>
          <button class="btn btn-sm btn-outline-primary" onclick="toggleAllFieldsVisibility()" style="flex: 1; font-size: 0.7rem; padding: 0.2rem 0.3rem;">
            <i class="fas fa-eye"></i> 표시/숨김
          </button>
          <button class="btn btn-sm btn-outline-info" onclick="setAllFieldsWidth('50%')" style="flex: 1; font-size: 0.7rem; padding: 0.2rem 0.3rem;">
            <i class="fas fa-columns"></i> 50%
          </button>
          <button class="btn btn-sm btn-outline-warning" onclick="setAllFieldsWidth('100%')" style="flex: 1; font-size: 0.7rem; padding: 0.2rem 0.3rem;">
            <i class="fas fa-expand-arrows-alt"></i> 100%
          </button>
        </div>
        
        <div id="fieldOrderList" class="field-order-list">
          <!-- JavaScript로 동적 생성 -->
        </div>
      </section>
      
      <!-- 텍스트 변환 설정 탭 -->
      <section class="preview-tab-content" id="text-format-content">
        <div class="alert alert-info" style="border-radius: 8px; background-color: #e7f3ff; border: 1px solid #b3d9ff; padding: 10px; margin-bottom: 0.75rem; font-size: 0.75rem;">
          <i class="fas fa-info-circle"></i> 주의사항과 기타표시사항의 표시 방식을 선택합니다. 줄바꿈을 그대로 보거나, 한 줄로 연결하거나, 구분 기호로 연결할 수 있습니다.
        </div>
        
        <div class="settings-row mb-3">
          <label class="form-label" for="textFormatMode" style="font-size: 0.85rem; font-weight: 600;">표시 방식</label>
          <select class="form-select form-select-sm" id="textFormatMode">
            <option value="KEEP">입력 데이터 그대로 보기</option>
            <option value="REMOVE">줄바꿈 없애기 (한 줄로)</option>
            <option value="REPLACE" selected>문장 구분 기호 추가</option>
          </select>
        </div>
        
        <div class="settings-row" id="delimiterRow">
          <label class="form-label" for="textDelimiter" style="font-size: 0.85rem; font-weight: 600;">구분 기호</label>
          <select class="form-select form-select-sm mb-2" id="textDelimiter">
            <option value="|" selected>| (수직선)</option>
            <option value=",">, (쉼표)</option>
            <option value="/">/ (슬래시)</option>
            <option value="•">• (원)</option>
            <option value="custom">직접 입력</option>
          </select>
          <div style="display: none;" id="customDelimiterGroup">
            <div class="input-group input-group-sm">
              <input type="text" class="form-control form-control-sm" id="customDelimiter" placeholder="구분 기호 입력 (최대 3자)" maxlength="3">
              <button class="btn btn-primary btn-sm" id="applyCustomDelimiter" type="button" title="적용">
                <i class="fas fa-check"></i> 적용
              </button>
            </div>
          </div>
        </div>
      </section>
      
      <!-- 분리배출마크 관리 탭 -->
      <section class="preview-tab-content" id="recycling-mark-content">
        <div id="recyclingMarkUiBox"></div>
      </section>
    </aside>

    <section class="preview-panel">
      <div id="previewContent" class="preview-content">
        <div class="preview-header-box">
          <div class="header-text">식품 등의 표시·광고에 관한 법률에 의한 한글표시사항</div>
        </div>
        
        <form style="display:none;">
          {% csrf_token %}
        </form>
        
        <input type="hidden" name="label_id" value="{{ label.my_label_id }}">
        <input type="hidden" id="update_datetime" name="update_datetime" value="{{ label.update_datetime|date:'Y-m-d H:i' }}">

        <table class="preview-table">
          <tbody id="previewTableBody" class="layout-vertical">
             <!-- Data will be rendered here by JavaScript -->
          </tbody>
        </table>
        
        <div class="footer-text">
          ezlabeling.com 에서 관련법규에 따라 작성되었습니다.
          <span class="creator-info">[{{ label.update_datetime|date:"Y-m-d H:i" }}]</span>
        </div>
      </div>
    </section>
  </main>

  <!-- Hidden data passed from backend -->
  <script id="preview-settings-data" type="application/json">
    {
      "width": "{{ label.prv_width|default:'10' }}",
      "length": "{{ label.prv_length|default:'11' }}",
      "font": "{{ label.prv_font|default:'Noto Sans KR' }}",
      "font_size": "{{ label.prv_font_size|default:'10' }}",
      "letter_spacing": "{{ label.prv_letter_spacing|default:'-5' }}",
      "line_spacing": "{{ label.prv_line_spacing|default:'1.2' }}",
      "recycling_mark": {
        "enabled": {% if label.prv_recycling_mark_enabled == 'Y' %}true{% else %}false{% endif %},
        "type": "{{ label.prv_recycling_mark_type|default:'' }}",
        "position_x": "{{ label.prv_recycling_mark_position_x|default:'0' }}",
        "position_y": "{{ label.prv_recycling_mark_position_y|default:'0' }}",
        "text": "{{ label.prv_recycling_mark_text|default:'' }}"
      }
    }
  </script>
  <script id="country-mapping-data" type="application/json">{{ country_mapping|safe }}</script>
  <script id="country-list-data" type="application/json">{{ country_list|safe }}</script>
  <script id="expiry-recommendation-data" type="application/json">{{ expiry_recommendation_json|safe }}</script>
  <script id="allergens-data" type="application/json">{{ allergens|safe }}</script>
  <script id="custom-fields-data" type="application/json">{{ custom_fields|safe }}</script>
    <script id="label-data" type="application/json">{{ label_data|safe }}</script>
  <script>
    // 백엔드 알레르기 데이터를 전역 변수로 설정
    try {
        const allergensScript = document.getElementById('allergens-data');
        if (allergensScript && allergensScript.textContent) {
            const allergensData = JSON.parse(allergensScript.textContent);
            if (Array.isArray(allergensData) && allergensData.length > 0) {
                window.allergensData = allergensData;
            }
        }
    } catch(e) {
        console.error('알레르기 데이터 로드 실패:', e);
    }
    // URL 파라미터 allergens 도 지원 (저장 전 선택값 포함)
    try {
        var _urlAllergens = new URLSearchParams(window.location.search).get('allergens');
        if (_urlAllergens && _urlAllergens.trim()) {
            var _parsed = _urlAllergens.split(',').map(function(a){ return a.trim(); }).filter(Boolean);
            if (_parsed.length > 0) {
                window.allergensData = _parsed;
                window.parentAllergens = _parsed;
            }
        }
    } catch(e) {
        console.error('URL allergens 파라미터 인식 실패:', e);
    }
  </script>

  <!-- External JS Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <!-- Label Preview JS -->
  <script src="{% static 'js/label/label_preview.js' %}?v=85.2"></script>

  <!-- 구글 스타일 Snackbar -->
  <div id="previewSnackbar" style="
    position: fixed;
    bottom: 1.5rem;
    left: 50%;
    transform: translateX(-50%) translateY(calc(100% + 2rem));
    background: #323232;
    color: #fff;
    padding: 0.75rem 1.25rem;
    border-radius: 4px;
    font-size: 0.875rem;
    line-height: 1.4;
    box-shadow: 0 3px 8px rgba(0,0,0,0.35), 0 1px 3px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    gap: 1rem;
    max-width: min(480px, calc(100vw - 2rem));
    z-index: 9999;
    transition: transform 0.25s cubic-bezier(0.4,0,0.2,1), opacity 0.25s;
    opacity: 0;
    pointer-events: none;
  ">
    <span id="previewSnackbarMsg" style="flex:1;"></span>
    <button id="previewSnackbarClose" onclick="hideSnackbar()" style="
      background: none; border: none; color: #90caf9;
      font-size: 0.8rem; font-weight: 600; cursor: pointer;
      padding: 0; flex-shrink: 0; letter-spacing: 0.05em;
    ">닫기</button>
  </div>
  <style>
    #previewSnackbar.snack-show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    #previewSnackbar.snack-error  { background: #b71c1c; }
    #previewSnackbar.snack-warning { background: #e65100; }
    #previewSnackbar.snack-success { background: #323232; }
  </style>

  <script>
    /* 파라미터
       is_owner       : 현재 로그인 사용자가 라벨 소유자인지 여부
       can_upload_pdf : PDF 문서함 업로드 권한 여부 */
    const IS_OWNER       = {{ is_owner|yesno:'true,false' }};
    const CAN_UPLOAD_PDF = {{ can_upload_pdf|yesno:'true,false' }};

    /* Snackbar 헬퍼 (구글 Material 스타일)
       - 아이프레임 내에 있을 때(고정 Snackbar가 클리핑될 수 있음) 포스트메시지로 부모에서 표시
       - 단독 실행 시에만 로컈 Snackbar 사용
       - type: 'success' | 'error' | 'warning' | 'info' */
    let _snackTimer = null;
    function showPreviewToast(message, type) {
      // iframe 안에 있으면 부모 페이지로 postMessage 전달
      if (window.self !== window.top) {
        try {
          window.parent.postMessage({ type: 'showSnackbar', message: message, snackType: type || 'success' }, '*');
        } catch(e) {}
        return;
      }
      // 단독 페이지: 로컈 Snackbar
      const el  = document.getElementById('previewSnackbar');
      const msg = document.getElementById('previewSnackbarMsg');
      if (!el || !msg) return;

      // 이전 타이머 취소
      if (_snackTimer) { clearTimeout(_snackTimer); _snackTimer = null; }

      // 타입별 색상 클래스 리셋
      el.classList.remove('snack-show', 'snack-error', 'snack-warning', 'snack-success');

      msg.textContent = message;
      if (type === 'error')   el.classList.add('snack-error');
      else if (type === 'warning') el.classList.add('snack-warning');
      else                    el.classList.add('snack-success');

      // 강제 reflow 후 슬라이드-업
      void el.offsetWidth;
      el.classList.add('snack-show');

      const duration = (type === 'error' || type === 'warning') ? 6000 : 4000;
      _snackTimer = setTimeout(hideSnackbar, duration);
    }
    function hideSnackbar() {
      const el = document.getElementById('previewSnackbar');
      if (el) el.classList.remove('snack-show', 'snack-error', 'snack-warning', 'snack-success');
      if (_snackTimer) { clearTimeout(_snackTimer); _snackTimer = null; }
    }
  </script>
  
  <script>
    document.addEventListener('DOMContentLoaded', function () {
        // --- DATA LOADING & STATE ---
        let countryMapping = {};
        let countryList = [];
        let checkedFields = {};
        let dataLoaded = false;
        let currentZoom = 1;
        let recyclingTextIdCounter = 0;
        
        // 텍스트 변환 설정 (전역)
        window.textFormatConfig = {
            mode: 'REPLACE',      // 'KEEP', 'REMOVE', 'REPLACE'
            delimiter: '|'        // 구분 기호
        };
        
        // 텍스트 변환 함수
        window.formatTextByOptions = function(text, config) {
            if (!text) return '';
            
            const mode = config.mode || 'REPLACE';
            const delimiter = config.delimiter || '|';
            
            if (mode === 'KEEP') {
                // 입력 데이터 그대로 보기
                return text;
            } else if (mode === 'REMOVE') {
                // 줄바꿈 없애기
                let result = text.replace(/\n/g, ' ');
                // 쉼표 앞 공백 제거, 뒤에만 공백
                result = result.replace(/\s*,\s*/g, ', ');
                result = result.replace(/\s+/g, ' ').trim();
                return result;
            } else if (mode === 'REPLACE') {
                // 문장 구분 기호 추가
                let lines = text.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                // 쉼표 정규화: 앞 공백 제거, 뒤에만 공백
                lines = lines.map(line => line.replace(/\s*,\s*/g, ', '));
                
                // 구분 기호로 연결 (쉼표는 뒤에만 공백, 나머지는 앞뒤 공백)
                if (delimiter === ',') {
                    return lines.join(', ');
                } else {
                    return lines.join(` ${delimiter} `);
                }
            }
            
            return text;
        };

        function safeJsonParse(elementId) {
            try {
                const element = document.getElementById(elementId);
                if (element && element.textContent.trim()) {
                    // Django template sometimes adds quotes around the JSON string.
                    const text = element.textContent.trim();
                    return JSON.parse(text);
                }
            } catch (e) {
                console.error(`"${elementId}" 데이터 파싱 오류:`, e, "콘텐츠:", document.getElementById(elementId)?.textContent);
            }
            return {};
        }

        countryMapping = safeJsonParse('country-mapping-data');
        countryList = safeJsonParse('country-list-data') || [];
        const allergensData = safeJsonParse('allergens-data') || [];
        const customFieldsData = safeJsonParse('custom-fields-data') || [];
        
        // 전역 변수로 설정 (필드 순서 조정 및 렌더링 함수에서 사용)
        window.customFieldsData = customFieldsData;
        window.countryList = countryList;

        // --- DOM ELEMENTS ---
        const previewContent = document.getElementById('previewContent');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const letterSpacingInput = document.getElementById('letterSpacingInput');
        const lineHeightInput = document.getElementById('lineHeightInput');
        const fontFamilySelect = document.getElementById('fontFamilySelect');
        const tbody = document.getElementById('previewTableBody');
        
        // constants.js에서 로드된 상수들 사용
        const DEFAULT_SETTINGS = window.DEFAULT_SETTINGS;
        const REGULATIONS = { ...window.REGULATIONS };
        // 백엔드 데이터 주입
        if (safeJsonParse('expiry-recommendation-data')) {
            REGULATIONS.expiry_recommendation = safeJsonParse('expiry-recommendation-data');
        }
        
        const recyclingMarkGroups = window.recyclingMarkGroupsDetailed;
        const recyclingMarkMap = {};
        recyclingMarkGroups.forEach(g => g.options.forEach(o => recyclingMarkMap[o.value] = o));
        const CM_TO_PX = 37.795;
        
        // 다중 분리배출마크 관리
        const MAX_RECYCLING_MARKS = 5;
        let recyclingMarks = []; // {id, markValue, position, compositeText}
        let markIdCounter = 0;

        // --- UTILS ---
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        // 미리보기 팝업 로깅 함수 (전역)
        window.logPreviewAction = function(action) {
            const labelIdInput = document.querySelector('input[name="label_id"]');
            const labelId = labelIdInput ? labelIdInput.value : null;
            
            if (!labelId) return;
            
            fetch('/label/log-preview-action/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ 
                    label_id: labelId,
                    action: action
                })
            }).catch(err => console.warn('미리보기 로깅 실패:', err));
        };
        
        // 탭 전환 함수
        function switchPreviewTab(tabName) {
            // 모든 탭 버튼의 active 클래스 제거
            document.querySelectorAll('.preview-tab').forEach(tab => {
                tab.classList.remove('active');
                tab.style.color = '#6c757d';
                tab.style.borderBottomColor = 'transparent';
                tab.style.fontWeight = '500';
            });
            
            // 모든 탭 콘텐츠 숨기기
            document.querySelectorAll('.preview-tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });
            
            // 선택된 탭 활성화
            const selectedTab = document.querySelector(`.preview-tab[data-tab="${tabName}"]`);
            const selectedContent = document.getElementById(`${tabName}-content`);
            
            if (selectedTab) {
                selectedTab.classList.add('active');
                selectedTab.style.color = '#0d6efd';
                selectedTab.style.borderBottomColor = '#0d6efd';
                selectedTab.style.fontWeight = '600';
            }
            
            if (selectedContent) {
                selectedContent.classList.add('active');
                selectedContent.style.display = 'flex'; /* flex column: CSS .preview-tab-content.active 와 연동 */
            }
            
            // localStorage에 현재 탭 저장
            try {
                localStorage.setItem('preview-active-tab', tabName);
            } catch (e) {
                console.error('탭 상태 저장 실패:', e);
            }
        }
        
        // 탭 클릭 이벤트 리스너
        document.querySelectorAll('.preview-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.dataset.tab;
                switchPreviewTab(tabName);
            });
        });
        
        // 페이지 로드 시 저장된 탭 복원
        function restoreActiveTab() {
            try {
                const savedTab = localStorage.getItem('preview-active-tab');
                if (savedTab) {
                    switchPreviewTab(savedTab);
                } else {
                    switchPreviewTab('table-settings'); // 기본 탭
                }
            } catch (e) {
                console.error('탭 상태 복원 실패:', e);
                switchPreviewTab('table-settings');
            }
        }

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            element.onmousedown = e => {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = () => { document.onmouseup = null; document.onmousemove = null; };
                document.onmousemove = e => {
                    e.preventDefault();
                    pos1 = pos3 - e.clientX;
                    pos2 = pos4 - e.clientY;
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    
                    // 새로운 위치 계산
                    let newTop = element.offsetTop - pos2;
                    let newLeft = element.offsetLeft - pos1;
                    
                    // 표 영역 제한 (previewContent 기준)
                    const container = document.getElementById('previewContent');
                    if (container) {
                        // 안전 여백 설정
                        const safeMargin = 2;
                        
                        // 최소/최대 위치 계산 (표 안에만 위치)
                        const minTop = safeMargin;
                        const maxTop = Math.max(safeMargin, container.offsetHeight - element.offsetHeight - safeMargin);
                        const minLeft = safeMargin;
                        const maxLeft = Math.max(safeMargin, container.offsetWidth - element.offsetWidth - safeMargin);
                        
                        // 위치 제한 적용
                        newTop = Math.max(minTop, Math.min(maxTop, newTop));
                        newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
                    }
                    
                    element.style.top = `${newTop}px`;
                    element.style.left = `${newLeft}px`;
                };
            };
        }

        // --- CORE FUNCTIONS ---
        function updatePreviewStyles() {
            if (!previewContent) return;
            const widthCm = parseFloat(widthInput.value) || 10;
            let fontSizePt = parseFloat(fontSizeInput.value) || 10;
            const letterSpacingPercent = parseInt(letterSpacingInput.value) || 0;
            const lineHeight = parseFloat(lineHeightInput.value) || 1.5;
            const fontFamily = fontFamilySelect.value;
            
            // 정확한 가로 길이 설정
            const widthPx = widthCm * CM_TO_PX;
            previewContent.style.width = `${widthPx}px`;
            previewContent.style.maxWidth = `${widthPx}px`;
            previewContent.style.minWidth = `${widthPx}px`;
            
            // 테이블 레이아웃 고정으로 열 너비 강제 적용
            const tables = previewContent.querySelectorAll('table');
            tables.forEach(table => {
                table.style.tableLayout = 'fixed';
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                
                // 인라인 스타일 추가로 첫 번째 열 너비 강제 고정
                if (!document.getElementById('label-preview-column-style')) {
                    const style = document.createElement('style');
                    style.id = 'label-preview-column-style';
                    style.textContent = `
                        #previewContent table th:first-child,
                        #previewContent table td:first-child,
                        #previewContent .label-preview-first-column {
                            width: 90px !important;
                            min-width: 90px !important;
                            max-width: 90px !important;
                            overflow: visible !important;
                            text-overflow: clip !important;
                            white-space: nowrap !important;
                            word-break: keep-all !important;
                            padding: 2px 4px !important;
                            box-sizing: border-box !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            });
            
            const elementsToStyle = previewContent.querySelectorAll('th, td, .header-text, .footer-text');
            elementsToStyle.forEach(el => {
                el.style.fontSize = `${fontSizePt}pt`;
                el.style.fontFamily = fontFamily;
                el.style.letterSpacing = `${letterSpacingPercent / 100}em`;
                el.style.lineHeight = lineHeight;
            });
            
            // 항목명 열(첫 번째 열) 너비를 절대값으로 고정 - CSS 덮어쓰기 방지
            const firstColumnCells = previewContent.querySelectorAll('th:first-child, td:first-child');
            const fixedWidth = '90px'; // 가로사이즈 12cm일 때 7글자가 잘 보이는 고정 너비
            firstColumnCells.forEach(cell => {
                // 특별한 클래스 추가로 CSS 우선순위 확보
                cell.classList.add('label-preview-first-column');
                
                // CSS 변수로 설정하여 다른 스타일 영향 차단
                cell.style.cssText += `
                    --column-width: ${fixedWidth};
                    width: var(--column-width) !important;
                    min-width: var(--column-width) !important;
                    max-width: var(--column-width) !important;
                    overflow: visible !important;
                    text-overflow: clip !important;
                    white-space: nowrap !important;
                    word-break: keep-all !important;
                    padding: 2px 4px !important;
                    box-sizing: border-box !important;
                    flex-shrink: 0 !important;
                `;
            });
            
            // 복합재질 텍스트 기본 스타일 적용
            const recyclingTextElements = previewContent.querySelectorAll('.recycling-text-line');
            recyclingTextElements.forEach(el => {
                el.style.fontFamily = fontFamily;
                el.style.letterSpacing = `${letterSpacingPercent / 100}em`;
                el.style.lineHeight = lineHeight; // 기본 줄간격 사용
            });

            requestAnimationFrame(() => {
                if(previewContent.scrollHeight > 0){
                    const contentHeightPx = previewContent.scrollHeight;
                    const heightCm = (contentHeightPx / CM_TO_PX).toFixed(1);
                    heightInput.value = `${heightCm} cm`;
                    
                    // 면적 계산 및 업데이트
                    const area = (widthCm * parseFloat(heightCm)).toFixed(1);
                    const areaDisplay = document.getElementById('areaDisplay');
                    if (areaDisplay) {
                        areaDisplay.textContent = area;
                    }
                }
            });
        }
        
        function convertCountryCodeToKorean(text) {
            if (!text || !countryMapping) return text;
            return text.replace(/\b[A-Z]{2}\b/g, match => countryMapping[match] || match);
        }

        function boldCountryNames(text, countries) {
            if (!text || !countries) return text;
            
            // countries가 배열이 아닌 경우 처리
            if (!Array.isArray(countries)) {
                console.warn('countries is not an array:', countries);
                return text;
            }
            
            if (countries.length === 0) return text;
            
            let processedText = text;
            
            // 긴 국가명부터 처리 (예: "영국" 먼저, "국" 나중에)
            const sortedCountries = countries.sort((a, b) => b.length - a.length);
            
            sortedCountries.forEach(country => {
                if(country){
                    const escapedCountry = country.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    
                    // 개선된 정규표현식:
                    // (?<![가-힣]): 앞에 한글이 오면 안 됨
                    // (?![가-힣]): 뒤에 한글이 오면 안 됨
                    const regex = new RegExp(`(?<![가-힣])(${escapedCountry}(\\s*산)?)(?![가-힣])`, 'gi');
                    processedText = processedText.replace(regex, '<strong>$1</strong>');
                }
            });
            return processedText;
        }
        
        // boldCountryNames를 전역 함수로 등록
        window.boldCountryNames = boldCountryNames;

        function renderTable(data) {
            if (!tbody) return;
            
            // window.currentLabelData 설정
            window.currentLabelData = data;
            
            // 데이터 로드 후 필드 리스트 업데이트 (무조건 실행)
            if (typeof window.updateFieldOrderFromData === 'function') {
                window.updateFieldOrderFromData();
            }
            
            // 필드 순서 UI도 업데이트
            if (typeof window.renderFieldOrderList === 'function') {
                window.renderFieldOrderList();
            }
            
            // renderTableWithLayout 함수가 있으면 사용, 없으면 기본 렌더링
            if (typeof window.renderTableWithLayout === 'function') {
                window.renderTableWithLayout(data, fieldOrderData?.layoutMode || 'vertical');
                return;
            }
            
            // 기본 렌더링 (fallback)
            tbody.innerHTML = '';
            
            // 항목 순서를 표시사항 작성 페이지와 일치시키기 위한 정렬된 필드 목록
            const ORDERED_FIELDS = [
                'prdlst_dcnm', 'prdlst_nm', 'ingredient_info',
                'content_weight', 'weight_calorie', 'prdlst_report_no',
                'country_of_origin', 'storage_method', 'frmlc_mtrqlt',
                'bssh_nm', 'distributor_address', 'repacker_address',
                'importer_address', 'pog_daycnt', 'rawmtrl_nm_display',
                'cautions', 'additional_info'
                // 'weight_calorie', 'nutrition_text'
            ];
            
            const FIELD_LABELS = { 
                prdlst_dcnm: '식품유형', 
                prdlst_nm: '제품명', 
                ingredient_info: '특정성분 함량',
                content_weight: '내용량', 
                weight_calorie: '내용량(열량)',
                prdlst_report_no: '품목보고번호',
                country_of_origin: '원산지', 
                storage_method: '보관 방법', 
                frmlc_mtrqlt: '용기·포장재질',
                bssh_nm:'제조원 소재지',
                distributor_address: '유통전문판매원', 
                repacker_address: '소분원', 
                importer_address: '수입원',
                pog_daycnt: '소비기한', 
                rawmtrl_nm_display: '원재료명', 
                cautions: '주의사항',
                additional_info: '기타표시사항',
                nutrition_text: '영양성분'
            };

            // 정렬된 순서대로 필드 표시
            ORDERED_FIELDS.forEach(key => {
                if (data[key]) {
                    const tr = document.createElement('tr');
                    const th = document.createElement('th');
                    const td = document.createElement('td');
                    th.textContent = FIELD_LABELS[key] || key;
                    
                    let value = data[key];

                    if (key === 'rawmtrl_nm_display') {
                        const container = document.createElement('div');
                        // 기존 패턴 매칭 제거
                        let mainText = value.replace(/\[알레르기 성분\s*:[^\]]+\]/, '').replace(/\[GMO\s*성분\s*:[^\]]+\]/, '').trim() || '';
                        
                        let processedText = boldCountryNames(mainText, countryList);
                        container.innerHTML = `<div>${processedText}</div>`;

                        // 알레르기 데이터 표시 (우선순위: parentAllergens > allergensData)
                        const displayAllergens = (typeof window.parentAllergens !== 'undefined' && window.parentAllergens && window.parentAllergens.length > 0) 
                            ? window.parentAllergens 
                            : (allergensData && allergensData.length > 0 ? allergensData : []);
                        
                        if (displayAllergens.length > 0) {
                            container.innerHTML += `<div style="background-color: #000; color: #fff; padding: 2px 5px; font-weight: bold; display: inline-block; margin-top: 5px;">${displayAllergens.join(', ')} 함유</div>`;
                        }
                        td.appendChild(container);

                    } else if (key === 'cautions' || key === 'additional_info') {
                        // 주의사항/기타표시: 텍스트 변환 설정 적용
                        let displayText = value;
                        
                        // textFormatConfig가 있으면 변환 적용
                        if (window.textFormatConfig && window.formatTextByOptions) {
                            displayText = window.formatTextByOptions(value, window.textFormatConfig);
                        }
                        
                        // KEEP 모드일 때는 줄바꿈을 <br>로 변환하여 화면에 표시
                        if (window.textFormatConfig && window.textFormatConfig.mode === 'KEEP') {
                            displayText = displayText.replace(/\n/g, '<br>');
                        }
                        
                        td.innerHTML = displayText;

                    } else if (key === 'country_of_origin'){
                         td.innerHTML = boldCountryNames(convertCountryCodeToKorean(value), countryList);
                    } else if (key === 'pog_daycnt') {
                        // 소비기한 필드: 선택된 항목명과 입력값을 간단하게 표시
                        const dateOption = data.date_option || '소비기한';
                        const dateValue = value || '';
                        
                        // 테이블 헤더는 선택된 옵션으로, 내용은 입력값만 표시
                        th.textContent = dateOption;  // 항목명을 테이블 헤더로
                        td.innerHTML = dateValue || '';
                        tr.appendChild(th);
                        tr.appendChild(td);
                        tbody.appendChild(tr);
                        return; // 기본 처리 로직을 건너뛰기 위해 return
                    } else {
                        td.innerHTML = value;
                    }
                    tr.appendChild(th);
                    tr.appendChild(td);
                    tbody.appendChild(tr);
                }
            });
            
            // 맞춤항목 표시 (표준 항목 이후)
            if (customFieldsData && customFieldsData.length > 0) {
                customFieldsData.forEach(field => {
                    if (field.label && field.value) {
                        const tr = document.createElement('tr');
                        const th = document.createElement('th');
                        const td = document.createElement('td');
                        th.textContent = field.label;
                        td.textContent = field.value;
                        tr.appendChild(th);
                        tr.appendChild(td);
                        tbody.appendChild(tr);
                    }
                });
            }
            
            updatePreviewStyles();
        }

        // 분리배출 마크에 텍스트 라인 추가
        function addTextToRecyclingMark(text) {
            const container = document.getElementById('recyclingMarkContainer');
            const image = document.getElementById('recyclingMarkImage') || container.querySelector('.recycling-mark-image');
            const textContainer = container.querySelector('.recycling-mark-text');
            if (!container || !image || !textContainer) {
                return;
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'recycling-text-line';
            textDiv.dataset.textId = `rtext-${++recyclingTextIdCounter || 1}`;
            textDiv.textContent = text;
            

            textDiv.style.cssText = `
                font-weight: 500;
                color: #000;
                line-height: 0.95;
                word-break: keep-all;
                text-align: center;
                margin-top: 0px;
                margin-bottom: 1px;
                padding-bottom: 1px;
                overflow: visible;
            `;
            textContainer.appendChild(textDiv);

            // 단순화된 폰트 크기 계산 공식
            const imageWidth = image.offsetWidth;
            const textLength = text.length;
            
            // 유동적 폰트 크기 계산: 기본 8pt에서 텍스트 길이에 따라 감소
            let fontSize = Math.max(8 - (textLength * 0.12), 5.5);
            
            textDiv.style.fontSize = `${fontSize}pt`;

            // 이미지 너비 기반 추가 조정
            let adjustmentAttempts = 0;
            while (textDiv.scrollWidth > imageWidth && fontSize > 5 && adjustmentAttempts < 5) {
                fontSize *= 0.9; // 10%씩 감소
                textDiv.style.fontSize = `${fontSize}pt`;
                adjustmentAttempts++;
            }

        }
        
        // 미리보기 영역에 마크(이미지+텍스트) 추가 및 드래그
        function setRecyclingMark(markValue, savedPosition = null, savedText = null) {
            const markObj = recyclingMarkMap[markValue];
            const previewContent = document.getElementById('previewContent');
            if (!previewContent || !markObj) return null;
            
            // 최대 개수 확인
            if (recyclingMarks.length >= MAX_RECYCLING_MARKS) {
                alert(`분리배출마크는 최대 ${MAX_RECYCLING_MARKS}개까지 추가할 수 있습니다.`);
                return null;
            }

            const markId = `recyclingMark_${++markIdCounter}`;
            
            const container = document.createElement('div');
            container.id = markId;
            container.className = 'recycling-mark-container';
            container.dataset.markValue = markValue;
            container.style.position = 'absolute';
            container.style.width = '60px';
            container.style.minHeight = '100px';
            container.style.cursor = 'move';
            container.style.textAlign = 'center';
            container.style.overflow = 'visible';
            container.style.zIndex = '1000';
            
            // 삭제 버튼 추가
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn btn-danger btn-sm';
            deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
            deleteBtn.style.cssText = 'position: absolute; top: -10px; right: -10px; width: 24px; height: 24px; padding: 0; border-radius: 50%; font-size: 12px; z-index: 1001; display: none;';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                removeRecyclingMark(markId);
            };
            
            // 호버 시 삭제 버튼 표시
            container.addEventListener('mouseenter', () => {
                deleteBtn.style.display = 'block';
            });
            container.addEventListener('mouseleave', () => {
                deleteBtn.style.display = 'none';
            });
            
            // 초기 위치 설정
            if (savedPosition) {
                container.style.left = savedPosition.left;
                container.style.top = savedPosition.top;
            } else {
                // 기존 마크들과 겹치지 않도록 위치 계산
                const offset = recyclingMarks.length * 70;
                container.style.left = `${10 + offset}px`;
                container.style.top = '10px';
            }
            
            // 컨테이너 내부 구조
            container.innerHTML = `
                <img class="recycling-mark-image" src="${markObj.img}" alt="${markObj.label}" style="width: 100%; height: auto; display: block; margin-bottom: -4px;">
                <div class="recycling-mark-text" style="margin-top: 0px; padding: 2px 0; line-height: 0.9; min-height: 30px; overflow: visible;"></div>
            `;
            
            container.insertBefore(deleteBtn, container.firstChild);
            previewContent.appendChild(container);
            
            // 드래그 가능하게 설정
            makeDraggable(container);
            container.ondragstart = () => false;
            
            // 마크 정보 저장
            const markInfo = {
                id: markId,
                markValue: markValue,
                compositeText: savedText || ''
            };
            recyclingMarks.push(markInfo);
            
            // 저장된 텍스트가 있으면 추가
            if (savedText) {
                const lines = savedText.split('/');
                const textContainer = container.querySelector('.recycling-mark-text');
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine) {
                        addTextToRecyclingMarkById(markId, trimmedLine);
                    }
                });
            }
            
            updateRecyclingMarkList();
            return markId;
        }
        
        // 마크 제거
        function removeRecyclingMark(markId) {
            const container = document.getElementById(markId);
            if (container) {
                container.remove();
            }
            recyclingMarks = recyclingMarks.filter(mark => mark.id !== markId);
            updateRecyclingMarkList();
        }
        
        // 특정 마크에 텍스트 추가
        function addTextToRecyclingMarkById(markId, text) {
            const container = document.getElementById(markId);
            if (!container) return;
            
            const image = container.querySelector('.recycling-mark-image');
            const textContainer = container.querySelector('.recycling-mark-text');
            if (!image || !textContainer) return;

            const textDiv = document.createElement('div');
            textDiv.className = 'recycling-text-line';
            textDiv.textContent = text;
            
            textDiv.style.cssText = `
                font-weight: 500;
                color: #000;
                line-height: 0.95;
                word-break: keep-all;
                text-align: center;
                margin-top: 0px;
                margin-bottom: 1px;
                padding-bottom: 1px;
                overflow: visible;
            `;
            textContainer.appendChild(textDiv);

            // 폰트 크기 자동 조정
            const imageWidth = image.offsetWidth;
            const textLength = text.length;
            let fontSize = Math.max(8 - (textLength * 0.12), 5.5);
            textDiv.style.fontSize = `${fontSize}pt`;

            let adjustmentAttempts = 0;
            while (textDiv.scrollWidth > imageWidth && fontSize > 5 && adjustmentAttempts < 5) {
                fontSize *= 0.9;
                textDiv.style.fontSize = `${fontSize}pt`;
                adjustmentAttempts++;
            }
        }
        
        // 마크 목록 UI 업데이트
        function updateRecyclingMarkList() {
            const listContainer = document.getElementById('recyclingMarkList');
            if (!listContainer) return;
            
            if (recyclingMarks.length === 0) {
                listContainer.innerHTML = '<div class="text-muted small">추가된 마크가 없습니다.</div>';
                return;
            }
            
            listContainer.innerHTML = recyclingMarks.map((mark, index) => {
                const markObj = recyclingMarkMap[mark.markValue];
                return `
                    <div class="d-flex align-items-center justify-content-between mb-2 p-2 border rounded" data-mark-id="${mark.id}">
                        <div class="d-flex align-items-center">
                            <img src="${markObj.img}" alt="${markObj.label}" style="width: 30px; height: 30px; margin-right: 8px;">
                            <small>${markObj.label}</small>
                        </div>
                        <button class="btn btn-sm btn-outline-danger mark-delete-btn" data-mark-id="${mark.id}">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
            }).join('');
            
            // 삭제 버튼에 이벤트 리스너 추가
            listContainer.querySelectorAll('.mark-delete-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const markId = this.getAttribute('data-mark-id');
                    removeRecyclingMark(markId);
                });
            });
        }
        
        // 기존 addTextToRecyclingMark 함수 (하위 호환성 유지)
        function addTextToRecyclingMark(text) {
            // 가장 최근에 추가된 마크에 텍스트 추가
            if (recyclingMarks.length > 0) {
                const lastMark = recyclingMarks[recyclingMarks.length - 1];
                addTextToRecyclingMarkById(lastMark.id, text);
            }
        }
        
        function renderRecyclingMarkUI() {
            const target = document.getElementById('recyclingMarkUiBox');
            if (!target || document.getElementById('recyclingMarkControls')) return;

            target.innerHTML = `
                <div class="alert alert-info" style="border-radius: 8px; background-color: #e7f3ff; border: 1px solid #b3d9ff; padding: 10px; margin-bottom: 0.75rem; font-size: 0.75rem;">
                    <i class="fas fa-info-circle"></i> 분리배출마크를 선택하고 추가하세요. 복합재질인 경우 재질 정보를 입력할 수 있으며, 최대 ${MAX_RECYCLING_MARKS}개까지 추가 가능합니다.
                </div>
                
                <div id="recyclingMarkControls">
                    <!-- 1. 마크 선택 + 복합재질 정보 입력 -->
                    <div class="settings-row-pair mb-3">
                        <div class="settings-row">
                            <label class="form-label" for="recyclingMarkSelect" style="font-size: 0.85rem; font-weight: 600;">마크 선택</label>
                            <select class="form-select form-select-sm" id="recyclingMarkSelect">
                                <option value="">마크를 선택하세요</option>
                                ${recyclingMarkGroups.map(group => 
                                    `<optgroup label="${group.group}">
                                        ${group.options.map(option => 
                                            `<option value="${option.value}">${option.label}</option>`
                                        ).join('')}
                                    </optgroup>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="settings-row">
                            <label class="form-label" for="additionalRecyclingText" style="font-size: 0.85rem; font-weight: 600;">복합재질 정보 (선택)</label>
                            <input type="text" class="form-control form-control-sm" 
                                   id="additionalRecyclingText" 
                                   placeholder="예: 몸체(종이)/뚜껑(PP)">
                        </div>
                    </div>
                    
                    <!-- 도움말 -->
                    <div class="form-text mt-1 mb-3" style="font-size: 0.75rem;">
                        <i class="fas fa-info-circle me-1"></i>
                        복합재질인 경우 입력하세요. 여러 재질은 '/'로 구분하세요.
                    </div>
                    
                    <!-- 2. 추가 버튼 -->
                    <div class="mb-3">
                        <button class="btn btn-primary btn-sm w-100" id="addRecyclingMarkBtn">
                            <i class="fas fa-plus me-1"></i>마크 추가
                        </button>
                    </div>
                    
                    <!-- 3. 추가된 마크 목록 -->
                    <div class="mt-3">
                        <label class="form-label" style="font-size: 0.85rem; font-weight: 600;">추가된 마크</label>
                        <div id="recyclingMarkList" class="border rounded p-2" style="min-height: 60px; background-color: #f8f9fa;">
                            <div class="text-muted small">추가된 마크가 없습니다.</div>
                        </div>
                    </div>
                </div>
            `;
            
            const select = document.getElementById('recyclingMarkSelect');
            const addBtn = document.getElementById('addRecyclingMarkBtn');
            const textInput = document.getElementById('additionalRecyclingText');
            
            // 마크 추가 버튼 (복합재질 정보도 함께 적용)
            addBtn.addEventListener('click', () => {
                const markValue = select.value;
                if (!markValue) { 
                    alert('마크를 선택해주세요.'); 
                    return; 
                }
                
                if (recyclingMarks.length >= MAX_RECYCLING_MARKS) {
                    alert(`분리배출마크는 최대 ${MAX_RECYCLING_MARKS}개까지 추가할 수 있습니다.`);
                    return;
                }
                
                // 복합재질 텍스트 가져오기
                const compositeText = textInput.value.trim();
                
                // 마크 추가
                const markId = setRecyclingMark(markValue);
                
                // 분리배출마크 추가 로깅
                if (markId && typeof window.logPreviewAction === 'function') {
                    window.logPreviewAction('preview_recycling_mark');
                }
                
                // 복합재질 정보가 있으면 추가
                if (markId && compositeText) {
                    const lines = compositeText.split('/');
                    lines.forEach(line => {
                        const trimmedLine = line.trim();
                        if (trimmedLine) {
                            addTextToRecyclingMarkById(markId, trimmedLine);
                        }
                    });
                    
                    // 마크 정보 업데이트
                    const mark = recyclingMarks.find(m => m.id === markId);
                    if (mark) {
                        mark.compositeText = compositeText;
                    }
                }
                
                // 입력 필드 초기화
                select.value = "";
                textInput.value = "";
            });
        }
        
        function updateZoom() {
            previewContent.style.transform = `scale(${currentZoom})`;
            document.getElementById('zoomDisplay').textContent = `${Math.round(currentZoom * 100)}%`;
        }
    
        function resetSettings() {
            widthInput.value = DEFAULT_SETTINGS.width;
            fontSizeInput.value = DEFAULT_SETTINGS.fontSize;
            letterSpacingInput.value = DEFAULT_SETTINGS.letterSpacing;
            lineHeightInput.value = DEFAULT_SETTINGS.lineHeight;
            fontFamilySelect.value = DEFAULT_SETTINGS.fontFamily;
            updatePreviewStyles();
        }

        // --- All validation functions from the JS file ---
        // (검증 함수들은 label_preview.js로 이동됨)

        // 분리배출마크 추천 함수
        function recommendRecyclingMarkByMaterial(packageMaterial) {
            const material = packageMaterial.toLowerCase();
            if (material.includes('무색페트') || material.includes('무색 페트')) return '무색페트';
            else if (material.includes('유색페트') || material.includes('유색 페트')) return '유색페트';
            else if (material.includes('pet') || material.includes('페트')) return '플라스틱(PET)';
            else if (material.includes('hdpe')) return '플라스틱(HDPE)';
            else if (material.includes('ldpe')) return '플라스틱(LDPE)';
            else if (material.includes('pp') || material.includes('폴리프로필렌')) return '플라스틱(PP)';
            else if (material.includes('ps') || material.includes('폴리스티렌')) return '플라스틱(PS)';
            else if (material.includes('기타') && material.includes('플라스틱')) return '기타플라스틱';
            else if (material.includes('종이') && !material.includes('팩')) return '종이';
            else if (material.includes('일반팩') || (material.includes('팩') && !material.includes('멸균'))) return '일반팩';
            else if (material.includes('멸균팩') || (material.includes('멸균') && material.includes('팩'))) return '멸균팩';
            else if (material.includes('철') || (material.includes('캔') && material.includes('철'))) return '캔류(철)';
            else if (material.includes('알미늄') || material.includes('알루미늄') || (material.includes('캔') && material.includes('알미늄'))) return '캔류(알미늄)';
            else if (material.includes('유리')) return '유리';
            else if (material.includes('복합재질') || material.includes('도포') || material.includes('첩합')) return '복합재질';
            else if (material.includes('비닐') && material.includes('pet')) return '비닐(PET)';
            else if (material.includes('비닐') && material.includes('hdpe')) return '비닐(HDPE)';
            else if (material.includes('비닐') && material.includes('ldpe')) return '비닐(LDPE)';
            else if (material.includes('비닐') && material.includes('pp')) return '비닐(PP)';
            else if (material.includes('비닐') && material.includes('ps')) return '비닐(PS)';
            else if (material.includes('비닐')) return '비닐(기타)';
            else return '';
        }

        // 5. 분리배출마크 (전역 함수로 노출)
        window.checkRecyclingMarkCompliance = function checkRecyclingMarkCompliance() {
            const errors = [];
            const suggestions = [];
            const packageMaterial = (checkedFields.frmlc_mtrqlt || '').toLowerCase();
            const select = document.getElementById('recyclingMarkSelect');
            const selectedMark = select ? select.value : '';



            if (!packageMaterial) {
                errors.push('포장재질을 표시하세요.');
                return { errors, suggestions };
            }

            // 사용자가 마크를 선택하지 않았으면 검증하지 않음
            if (!selectedMark || selectedMark === '미표시') {
                return { errors, suggestions };
            }

            // 마크와 재질 키워드 간의 호환성 검증 헬퍼 함수
            const isCompatible = (mark, materialKeywords) => {
                return materialKeywords.some(keyword => packageMaterial.includes(keyword));
            };

            let compatible = false;
            switch (selectedMark) {
                case '무색페트':
                    compatible = isCompatible(selectedMark, ['pet', '페트', '무색']);
                    break;
                case '유색페트':
                    compatible = isCompatible(selectedMark, ['pet', '페트', '유색']);
                    break;
                case '플라스틱(PET)':
                    compatible = isCompatible(selectedMark, ['pet', '페트']);
                    break;
                case '플라스틱(LDPE)':
                    compatible = isCompatible(selectedMark, ['ldpe', '저밀도', '폴리에틸렌', 'pe']);
                    break;
                case '플라스틱(HDPE)':
                    compatible = isCompatible(selectedMark, ['hdpe', '고밀도', '폴리에틸렌', 'pe']);
                    break;
                case '플라스틱(PP)':
                    compatible = isCompatible(selectedMark, ['pp', '피피', '폴리프로필렌']);
                    break;
                case '플라스틱(PS)':
                    compatible = isCompatible(selectedMark, ['ps', '피에스', '폴리스티렌']);
                    break;
                case '기타플라스틱':
                    compatible = isCompatible(selectedMark, ['기타', '플라스틱', 'other']);
                    break;
                case '캔류(철)':
                    compatible = isCompatible(selectedMark, ['철', 'steel', '캔']);
                    break;
                case '캔류(알미늄)':
                    compatible = isCompatible(selectedMark, ['알미늄', '알루미늄', 'aluminum', 'al', '캔']);
                    break;
                case '종이':
                    compatible = isCompatible(selectedMark, ['종이', 'paper']) && !packageMaterial.includes('팩');
                    break;
                case '일반팩':
                    compatible = packageMaterial.includes('팩') && !packageMaterial.includes('멸균');
                    break;
                case '멸균팩':
                    compatible = packageMaterial.includes('멸균') && packageMaterial.includes('팩');
                    break;
                case '유리':
                    compatible = isCompatible(selectedMark, ['유리', 'glass']);
                    break;
                case '복합재질':
                    compatible = isCompatible(selectedMark, ['복합재질', '도포', '첩합', '코팅']);
                    break;
                case '비닐(PET)':
                    compatible = isCompatible(selectedMark, ['비닐', 'pet', '페트']);
                    break;
                case '비닐(HDPE)':
                    compatible = isCompatible(selectedMark, ['비닐', 'hdpe', '고밀도']);
                    break;
                case '비닐(LDPE)':
                    compatible = isCompatible(selectedMark, ['비닐', 'ldpe', '저밀도']);
                    break;
                case '비닐(PP)':
                    compatible = isCompatible(selectedMark, ['비닐', 'pp', '폴리프로필렌']);
                    break;
                case '비닐(PS)':
                    compatible = isCompatible(selectedMark, ['비닐', 'ps', '폴리스티렌']);
                    break;
                case '비닐(기타)':
                    compatible = isCompatible(selectedMark, ['비닐', '기타']);
                    break;
                default:
                    const recommendedMark = recommendRecyclingMarkByMaterial(packageMaterial);
                    compatible = (selectedMark === recommendedMark);
                    break;
            }


            
            if (!compatible) {
                errors.push(
                    `포장재질("${checkedFields.frmlc_mtrqlt}")과 분리배출마크("${selectedMark}")가 일치하지 않습니다. 사용된 포장재질과 분리배출마크를 재확인하세요.`
                );
            }

            return { errors, suggestions };
        }

        // 6. 소비기한
        function checkExpiryCompliance() {
            const errors = [];
            const suggestions = [];
            const foodType = (checkedFields.prdlst_dcnm || '').trim();
            const expiry = (checkedFields.pog_daycnt || '').trim();
            const storageMethod = (checkedFields.storage_method || '').trim();

            if (!expiry || !foodType) {
                return { errors, suggestions };
            }

            // 냉동식품 또는 장기보존식품(통조림, 레토르트)은 검증에서 제외
            const isFrozen = storageMethod.toLowerCase().includes('냉동') || foodType.toLowerCase().includes('냉동');
            const isLongTermStorage = foodType.includes('통조림') || foodType.includes('병조림') || foodType.includes('레토르트');

            if (isFrozen || isLongTermStorage) {
                return { errors, suggestions }; // 검증 대상이 아니므로 종료
            }

            // 1. 식품유형에 맞는 권장 소비기한 찾기
            const recommendationKeys = Object.keys(REGULATIONS.expiry_recommendation || {}).sort((a, b) => b.length - a.length);
            let recommendation = null;
            for (const key of recommendationKeys) {
                if (foodType.includes(key)) {
                    recommendation = REGULATIONS.expiry_recommendation[key];
                    break;
                }
            }

            if (!recommendation || typeof recommendation.shelf_life !== 'number') {
                return { errors, suggestions }; // 검증 대상이 아니면 종료
            }

            // 2. 입력된 소비기한을 '일' 단위로 변환
            let totalDays = 0;
            const yearMatch = expiry.match(/(\d+)\s*년/);
            const monthMatch = expiry.match(/(\d+)\s*개월/);
            const dayMatch = expiry.match(/(\d+)\s*일/);

            if (yearMatch) {
                totalDays = parseInt(yearMatch[1], 10) * 365;
            } else if (monthMatch) {
                totalDays = parseInt(monthMatch[1], 10) * 30;
            } else if (dayMatch) {
                totalDays = parseInt(dayMatch[1], 10);
            }

            if (totalDays === 0) {
                return { errors, suggestions }; // 유효한 기간이 아니면 종료
            }

            // 3. 권장 소비기한을 '일' 단위로 변환
            let recommendedDays = 0;
            if (recommendation.unit === 'months') {
                recommendedDays = recommendation.shelf_life * 30;
            } else if (recommendation.unit === 'days') {
                recommendedDays = recommendation.shelf_life;
            }

            // 4. 비교 및 오류 메시지 생성
            if (recommendedDays > 0 && totalDays > recommendedDays) {
                const unitText = recommendation.unit === 'months' ? '개월' : '일';
                const suggestionMsg = `권장 소비기한(${recommendation.shelf_life}${unitText})을 초과하였습니다. 설정 근거를 반드시 확인하시기 바랍니다.`;
                suggestions.push(suggestionMsg);
            }

            return { errors, suggestions };
        }
        
        function checkRecyclingMarkCompliance() { 
            const errors = [];
            const suggestions = [];
            
            // 분리배출마크 검사
            const frmlcMtrqlt = checkedFields.frmlc_mtrqlt || '';
            const container = document.getElementById('recyclingMarkContainer');
            
            if (frmlcMtrqlt) {
                if (!container) {
                    errors.push(`포장재질(${frmlcMtrqlt})에 대한 분리배출마크가 필요합니다.`);
                    
                    // 포장재질에 따른 추천 마크
                    if (frmlcMtrqlt.includes('종이')) {
                        suggestions.push("종이 분리배출마크 추가 필요");
                    } else if (frmlcMtrqlt.includes('페트') || frmlcMtrqlt.includes('PET')) {
                        suggestions.push("플라스틱(PET) 분리배출마크 추가 필요");
                    } else if (frmlcMtrqlt.includes('PP') || frmlcMtrqlt.includes('폴리프로필렌')) {
                        suggestions.push("플라스틱(PP) 분리배출마크 추가 필요");
                    } else if (frmlcMtrqlt.includes('유리')) {
                        suggestions.push("유리 분리배출마크 추가 필요");
                    } else if (frmlcMtrqlt.includes('복합재질')) {
                        suggestions.push("복합재질 분리배출마크 추가 필요");
                    }
                }
                
                // 복합재질 마크에 추가 설명이 있는지 확인
                if (container && frmlcMtrqlt.includes('복합재질')) {
                    const textContainer = container.querySelector('.recycling-mark-text');
                    if (!textContainer || !textContainer.textContent.trim()) {
                        errors.push("복합재질 분리배출마크에 재질 정보(예: 몸체(종이)/뚜껑(PP))를 추가해야 합니다.");
                    }
                }
            }
            
            return { errors, suggestions };
        }
        
        function checkExpiryCompliance() { 
            const errors = [];
            const suggestions = [];
            
            // 소비기한 검사
            const pogDaycnt = checkedFields.pog_daycnt || '';
            const foodType = checkedFields.prdlst_dcnm || '';
            
            if (pogDaycnt && foodType) {
                // REGULATIONS.expiry_recommendation에서 식품유형별 권장 소비기한 확인
                const recommendation = REGULATIONS.expiry_recommendation[foodType];
                
                if (recommendation) {
                    const { shelf_life, unit } = recommendation;
                    const recommendedMonths = parseInt(shelf_life);
                    
                    if (!isNaN(recommendedMonths)) {
                        // 권장 소비기한과 입력된 소비기한 비교
                        const currentMonthMatch = pogDaycnt.match(/(\d+)\s*개월/);
                        
                        if (currentMonthMatch) {
                            const currentMonths = parseInt(currentMonthMatch[1]);
                            
                            if (!isNaN(currentMonths) && currentMonths > recommendedMonths) {
                                suggestions.push(`현재 소비기한(${currentMonths}개월)이 ${foodType}의 권장 소비기한(${recommendedMonths}개월)보다 깁니다. 검토가 필요합니다.`);
                            }
                        }
                    }
                }
            }
            
            return { errors, suggestions };
        }
    
        function showValidationModal() {
            // 기존 모달과 오버레이 제거
            let modal = document.getElementById('validationModal');
            if (modal) modal.remove();
            
            // 혹시 남아있는 modal-backdrop 요소 제거
            const backdrops = document.querySelectorAll('.modal-backdrop');
            backdrops.forEach(backdrop => backdrop.remove());
            
            // 모달 생성
            modal = document.createElement('div');
            modal.id = 'validationModal';
            modal.className = 'modal fade';
            modal.innerHTML = `<div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">규정 검증 결과</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><table class="table table-bordered"><thead><tr><th>검증 항목</th><th>상태</th><th>결과 및 제안</th></tr></thead><tbody id="validationResultBody"></tbody></table></div></div></div>`;
            document.body.appendChild(modal);
            
            // 모달이 닫힐 때 오버레이 제거 이벤트 추가
            modal.addEventListener('hidden.bs.modal', function() {
                document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
            });
            
            new bootstrap.Modal(modal).show();
            return modal;
        }
    
        async function validateSettings_HTML_DEPRECATED() {
            // 기존 backdrop 제거
            document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
            
            // 검증 항목 순서 및 매핑
            const validationItems = [
                {
                    label: '표시면 면적',
                    check: () => {
                        const width = parseFloat(widthInput?.value) || 0;
                        const height = parseFloat(document.getElementById('heightInput').value) || 0;
                        const area = width * height;
                        return {
                            ok: area >= 40,
                            errors: area < 40 ? [
                                `<strong style="color:#222;">표시면 면적은 최소 40cm² 이상이어야 합니다 («식품 등의 표시기준» 제4조).</strong>`
                            ] : [],
                            suggestions: area < 40 ? [
                                `<strong style="color:#222;">면적을 40cm² 이상으로 조정하세요.</strong>`
                            ] : []
                        };
                    },
                    always: true
                },
                {
                    label: '글꼴 크기',
                    check: () => {
                        const fontSize = parseFloat(fontSizeInput?.value) || 10;
                        return {
                            ok: fontSize >= REGULATIONS.font_size.general.min,
                            errors: fontSize < REGULATIONS.font_size.general.min ? [
                                `<strong style="color:#222;">글꼴 크기는 최소 ${REGULATIONS.font_size.general.min}pt 이상이어야 합니다 («식품 등의 표시기준» 제6조).</strong>`
                            ] : [],
                            suggestions: fontSize < REGULATIONS.font_size.general.min ? [
                                `<strong style="color:#222;">글꼴 크기를 ${REGULATIONS.font_size.general.min}pt 이상으로 조정하세요.</strong>`
                            ] : []
                        };
                    },
                    always: true
                },
                {
                    label: '제품명 성분 표시',
                    check: () => {
                        const result = checkFarmSeafoodCompliance();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    }
                },
                {
                    label: '필수 문구',
                    check: () => {
                        const result = checkFoodTypePhrasesUnified();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    }
                },
                {
                    label: '사용금지 문구',
                    check: () => checkForbiddenPhrases()
                },
                {
                    label: '알레르기 중복 표시',
                    check: () => {
                        const result = checkAllergenDuplication();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    }
                },
                {
                    label: '분리배출마크',
                    check: () => {
                        const result = checkRecyclingMarkCompliance();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    },
                    always: true
                },
                {
                    label: '소비기한',
                    check: () => {
                        const result = checkExpiryCompliance();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    }
                }
            ];

            const results = validationItems.map(item => item.check());
            
            const modal = showValidationModal();
            const tbody = modal.querySelector('#validationResultBody');
            tbody.innerHTML = '';

            let hasErrors = false;

            // tbody에 모든 검증 항목을 한 번에 추가 (tr을 누적해서 innerHTML로 할당)
            let rowsHtml = '';
            for (let i = 0; i < validationItems.length; i++) {
                const item = validationItems[i];
                const result = results[i];

                rowsHtml += `<tr>`;

                // 항목명
                rowsHtml += `<td>${item.label}</td>`;

                // 결과
                if (!result.errors || result.errors.length === 0) {
                    rowsHtml += `<td><span class="text-success">적합</span></td>`;
                } else {
                    rowsHtml += `<td><span class="text-danger">재검토</span></td>`;
                    hasErrors = true;
                }

                // 에러/수정제안
                let msg = '';
                if (result.errors && result.errors.length > 0) msg += result.errors.join('<br>');
                if (result.suggestions && result.suggestions.length > 0) {
                    if (msg) msg += ' | ';
                    msg += result.suggestions.join('<br>');
                }
                rowsHtml += `<td>${msg}</td>`;

                rowsHtml += `</tr>`;
            }
            tbody.innerHTML = rowsHtml;
        }
    
        async function exportToPDF() {
            const pdfBtn = document.getElementById('exportPdfBtn');
            if (pdfBtn) { pdfBtn.disabled = true; pdfBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>PDF 생성 중...'; }
            try {
                // PDF 저장 로깅
                const urlParams = new URLSearchParams(window.location.search);
                const labelId = urlParams.get('label_id');
                if (labelId) {
                    try {
                        await fetch('/label/log-pdf-save/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCookie('csrftoken')
                            },
                            body: JSON.stringify({ 
                                label_id: labelId,
                                source: 'preview'
                            })
                        });
                    } catch (logError) {
                        console.warn('로깅 실패:', logError);
                    }
                }

                previewContent.style.transform = 'scale(1)';
                const { jsPDF } = window.jspdf;
                const canvas = await html2canvas(previewContent, { scale: 3, useCORS: true });
                const imgData = canvas.toDataURL('image/png');
                const widthCm  = parseFloat(widthInput.value);
                const heightCm = parseFloat(heightInput.value.replace(' cm', ''));
                const orientation = widthCm > heightCm ? 'l' : 'p';
                const pdf = new jsPDF(orientation, 'cm', [widthCm, heightCm]);
                pdf.addImage(imgData, 'PNG', 0, 0, widthCm, heightCm);

                const productName = checkedFields.prdlst_nm || 'label';
                const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filename = `한글표시사항_${productName}_${date}.pdf`;

                // 로컬 다운로드
                pdf.save(filename);

                // 서버 업로드 (문서함 등록) 라벨ID가 있는 경우만
                if (labelId) {
                    try {
                        if (pdfBtn) { pdfBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>문서함 등록 중...'; }

                        const pdfBlob = pdf.output('blob');
                        const formData = new FormData();
                        formData.append('label_id', labelId);
                        formData.append('pdf_file', pdfBlob, filename);

                        const uploadRes = await fetch('/label/upload-label-pdf/', {
                            method: 'POST',
                            headers: { 'X-CSRFToken': getCookie('csrftoken') },
                            body: formData,
                        });
                        const uploadJson = await uploadRes.json();

                        if (uploadJson.success) {
                            const msg = uploadJson.updated
                                ? `문서함에 한글표시사항도안이 업데이트되었습니다. (버전 ${uploadJson.version})`
                                : '문서함에 한글표시사항도안이 등록되었습니다.';
                            showPreviewToast(msg, 'success');
                        } else {
                            console.warn('문서함 등록 실패:', uploadJson.error);
                            showPreviewToast('문서함 등록 실패: ' + (uploadJson.error || ''), 'warning');
                        }
                    } catch (uploadErr) {
                        console.warn('문서함 업로드 에러:', uploadErr);
                        showPreviewToast('문서함 등록 중 오류가 발생했습니다.', 'warning');
                    }
                } else {
                    // label_id 없는 경우(팝업 직접 열기 등)는 다운로드 성공만 알림
                    showPreviewToast('PDF가 저장되었습니다.', 'success');
                }
            } catch (error) {
                console.error('PDF generation error:', error);
                showPreviewToast('PDF 생성 중 오류가 발생했습니다.', 'error');
            } finally {
                updateZoom();
                if (pdfBtn) { pdfBtn.disabled = false; pdfBtn.innerHTML = '<i class="fas fa-file-arrow-down me-1"></i>PDF 저장'; }
            }
        }

        // 현재 분리배출마크 정보 수집 (개선된 버전)
        // 현재 분리배출마크 정보 수집 (다중 마크 지원)
        function getCurrentRecyclingMarkInfo() {
            if (recyclingMarks.length === 0) {
                return {
                    enabled: false,
                    marks: []
                };
            }
            
            const marksData = recyclingMarks.map(mark => {
                const container = document.getElementById(mark.id);
                if (!container) return null;
                
                // px 단위 제거하여 숫자만 저장
                const posX = parseFloat(container.style.left) || 0;
                const posY = parseFloat(container.style.top) || 0;
                
                return {
                    type: mark.markValue,
                    position_x: posX,
                    position_y: posY,
                    text: mark.compositeText || ''
                };
            }).filter(m => m !== null);
            
            return {
                enabled: marksData.length > 0,
                marks: marksData
            };
        }
        
        // 추천 마크 갱신
        function updateRecyclingMarkUI(packageText) {
            if (!packageText) return;
            
            const material = packageText.toLowerCase();
            let recommendedMark = '';
            
            // 다양한 재질에 따른 마크 추천
            if (material.includes('무색페트') || material.includes('무색 페트')) recommendedMark = '무색페트';
            else if (material.includes('유색페트') || material.includes('유색 페트')) recommendedMark = '유색페트';
            else if (material.includes('페트') || material.includes('pet')) recommendedMark = '플라스틱(PET)';
            else if (material.includes('hdpe') || material.includes('고밀도폴리에틸렌')) recommendedMark = '플라스틱(HDPE)';
            else if (material.includes('ldpe') || material.includes('저밀도폴리에틸렌')) recommendedMark = '플라스틱(LDPE)';
            else if (material.includes('pp') || material.includes('폴리프로필렌')) recommendedMark = '플라스틱(PP)';
            else if (material.includes('ps') || material.includes('폴리스티렌')) recommendedMark = '플라스틱(PS)';
            else if (material.includes('pvc') || material.includes('폴리염화비닐')) recommendedMark = '플라스틱(PVC)';
            else if (material.includes('플라스틱') && !material.includes('(')) recommendedMark = '기타플라스틱';
            else if (material.includes('종이팩') || material.includes('종이 팩')) recommendedMark = '종이팩';
            else if (material.includes('종이')) recommendedMark = '종이';
            else if (material.includes('알루미늄') || material.includes('알미늄')) recommendedMark = '알루미늄';
            else if (material.includes('철') && !material.includes('캔')) recommendedMark = '철';
            else if ((material.includes('캔') && material.includes('금속')) || material.includes('금속캔')) recommendedMark = '금속캔';
            else if (material.includes('유리')) recommendedMark = '유리';
            else if (material.includes('비닐')) recommendedMark = '비닐';
            else if (material.includes('/') || (material.match(/[가-힣]+\([가-힣]+\)/) && material.match(/[가-힣]+\([가-힣]+\)/g).length > 1)) recommendedMark = '복합재질';
            
            if (recommendedMark) {
                const select = document.getElementById('recyclingMarkSelect');
                const addBtn = document.getElementById('addRecyclingMarkBtn');
                if (select && addBtn && addBtn.textContent === '추가') {
                    select.value = recommendedMark;
                    setRecyclingMark(recommendedMark);
                    addBtn.textContent = '제거';
                    addBtn.classList.replace('btn-outline-primary', 'btn-danger');
                    
                    const selectedOption = select.options[select.selectedIndex];
                    const additionalInputBox = document.getElementById('additionalTextInputBox');
                    if (additionalInputBox && selectedOption.dataset.isComposite === 'true') {
                        additionalInputBox.style.display = 'block';
                        // 복합재질이면 자동 포커스
                        setTimeout(() => document.getElementById('additionalRecyclingText').focus(), 100);
                    }
                }
            }
        }

        // 설정 저장
        function savePreviewSettings() {

            
            // labelId 찾기 시도 1: input 필드에서
            const labelInput = document.querySelector('input[name="label_id"]');

            const labelId = labelInput?.value;

            
            // labelId 찾기 시도 2: URL에서
            let finalLabelId = labelId;
            if (!finalLabelId) {
                const urlParams = new URLSearchParams(window.location.search);
                finalLabelId = urlParams.get('label_id');

            }
            
            if (!finalLabelId) {
                console.error('label_id를 찾을 수 없습니다. input:', labelInput, 'URL params:', new URLSearchParams(window.location.search).toString());
                alert('라벨 ID를 찾을 수 없습니다. 페이지를 새로고침해주세요.');
                return;
            }
            


            // 분리배출마크 정보 수집

            const recyclingMarkInfo = getCurrentRecyclingMarkInfo();



            // 세로 길이는 "22.6 cm" 형식이므로 숫자 부분만 추출
            const heightValue = document.getElementById('heightInput')?.value || '10';
            const heightNumber = parseFloat(heightValue.replace(/[^0-9.-]/g, '')) || 10;
            
            const data = {
                label_id: finalLabelId,
                layout: 'vertical', // 레이아웃은 항상 세로형으로 고정
                width: parseFloat(widthInput?.value) || 10,
                length: heightNumber,
                font: document.getElementById('fontFamilySelect')?.value || "'Noto Sans KR'",
                font_size: parseFloat(fontSizeInput?.value) || 10,
                letter_spacing: parseInt(letterSpacingInput?.value) || -5,
                line_spacing: parseFloat(document.getElementById('lineHeightInput')?.value) || 1.2,
                recycling_mark: recyclingMarkInfo
            };
            
            const csrfToken = getCookie('csrftoken') || document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';


            fetch('/label/save_preview_settings/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify(data)
            })
            .then(res => {

                return res.json();
            })
            .then(res => {

                if (res.success) {
                    // 설정 저장 로깅
                    if (typeof window.logPreviewAction === 'function') {
                        window.logPreviewAction('preview_settings_save');
                    }

                    // 성공 메시지 표시
                    const saveBtn = document.getElementById('saveSettingsBtn');
                    if (saveBtn) {
                        const originalText = saveBtn.innerHTML;
                        saveBtn.innerHTML = '<i class="fas fa-check me-1"></i>저장완료';
                        saveBtn.classList.remove('btn-outline-success');
                        saveBtn.classList.add('btn-success');
                        saveBtn.disabled = false;
                        setTimeout(() => {
                            saveBtn.innerHTML = originalText;
                            saveBtn.classList.remove('btn-success');
                            saveBtn.classList.add('btn-outline-success');
                        }, 2000);
                    }
                    showPreviewToast('미리보기 설정이 저장되었습니다.', 'success');
                } else if (res.reason === 'not_owner') {
                    // 공유 사용자는 설정 저장 불가 (정상 흐름)
                    showPreviewToast('설정 저장은 라벨 소유자만 가능합니다.', 'warning');
                    const saveBtn = document.getElementById('saveSettingsBtn');
                    if (saveBtn) { saveBtn.disabled = false; }
                } else {
                    showPreviewToast('설정 저장 실패: ' + (res.error || ''), 'error');
                    const saveBtn = document.getElementById('saveSettingsBtn');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = '<i class="fas fa-save me-1"></i>설정 저장';
                    }
                }
            })
            .catch(err => {
                console.error('저장 에러:', err);
                showPreviewToast('설정 저장 에러: ' + err, 'error');
                const saveBtn = document.getElementById('saveSettingsBtn');
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = '<i class="fas fa-save me-1"></i>설정 저장';
                }
            });
        }
    
        // 분리배출마크 복원 (첫 번째 마크만)
        function restoreRecyclingMark(markData) {
            if (!markData || !markData.enabled) {
                return;
            }
            
            // 단일 마크 복원
            if (markData.type) {
                const position = {
                    left: `${parseFloat(markData.position_x) || 10}px`,
                    top: `${parseFloat(markData.position_y) || 10}px`
                };
                setRecyclingMark(markData.type, position, markData.text);
            }
        }

        // 저장된 미리보기 설정 로드
        function loadSavedPreviewSettings() {
            try {
                // 1. 백엔드에서 전달된 설정 확인
                const settingsScript = document.getElementById('preview-settings-data');
                let settings = {};
                
                if (settingsScript && settingsScript.textContent && settingsScript.textContent.trim() !== '{}') {
                    settings = JSON.parse(settingsScript.textContent);
                }
                
                // 2. localStorage에서 최근 설정 확인 (우선순위 높음)
                const labelInput = document.querySelector('input[name="label_id"]');
                const labelId = labelInput?.value;
                
                if (labelId) {
                    const savedSettings = sessionStorage.getItem('labelPreviewSettings_' + labelId);
                    if (savedSettings) {
                        const localSettings = JSON.parse(savedSettings);
                        // 로컬 설정이 있으면 백엔드 설정보다 우선
                        settings = { ...settings, ...localSettings };
                    }
                }
                
                // 기본 설정 복원
                if (settings.width) {
                    if (widthInput) {
                        widthInput.value = settings.width;

                    }
                }
                
                if (settings.font_size) {
                    if (fontSizeInput) {
                        fontSizeInput.value = settings.font_size;

                    }
                }
                
                if (settings.letter_spacing !== undefined) {
                    if (letterSpacingInput) {
                        letterSpacingInput.value = settings.letter_spacing;

                    }
                }
                
                if (settings.line_spacing) {
                    const lineHeightInput = document.getElementById('lineHeightInput');
                    if (lineHeightInput) {
                        lineHeightInput.value = settings.line_spacing;

                    }
                }
                
                // 폰트 설정 (빈값이면 기본값 사용)
                const fontFamilySelect = document.getElementById('fontFamilySelect');
                if (fontFamilySelect) {
                    let fontValue = settings.font || 'Noto Sans KR';
                    
                    // 폰트 이름을 실제 option value와 매칭
                    if (fontValue.includes('Noto Sans KR')) {
                        fontValue = "'Noto Sans KR', sans-serif";
                    } else if (fontValue.includes('Nanum Gothic')) {
                        fontValue = "'Nanum Gothic', sans-serif";
                    } else if (fontValue.includes('Nanum Myeongjo')) {
                        fontValue = "'Nanum Myeongjo', serif";
                    } else {
                        // 기본값
                        fontValue = "'Noto Sans KR', sans-serif";
                    }
                    
                    fontFamilySelect.value = fontValue;

                }
                
                // 분리배출마크 설정 복원
                const recyclingMark = settings.recycling_mark;
                if (recyclingMark) {
                    setTimeout(() => {
                        restoreRecyclingMark(recyclingMark);
                    }, 1500);
                }
                
                // 설정 복원 후 스타일 업데이트
                setTimeout(() => {
                    if (typeof updatePreviewStyles === 'function') {
                        updatePreviewStyles();

                    }
                }, 100);
                
            } catch (error) {
                console.error('저장된 설정 로드 중 오류:', error);
            }
        }
    
        // --- EVENT LISTENERS & INITIALIZATION ---
        function setupEventListeners() {
            // readonly 모드에서는 설정 관련 이벤트 리스너 건너뛰기
            const isReadonly = new URLSearchParams(window.location.search).get('readonly') === 'true';
            
            if (!isReadonly) {
                const inputs = ['widthInput', 'fontSizeInput', 'letterSpacingInput', 'lineHeightInput', 'fontFamilySelect'];
                inputs.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', debounce(updatePreviewStyles, 250));
                        // 표 설정 변경 시 로깅 (디바운스로 한 번만)
                        element.addEventListener('change', debounce(function() {
                            if (typeof window.logPreviewAction === 'function') {
                                window.logPreviewAction('preview_table_settings');
                            }
                        }, 500));
                    }
                });
                document.getElementById('resetSettingsBtn')?.addEventListener('click', resetSettings);
                // validateButton 이벤트 리스너는 label_preview.js에서 처리
                const saveBtn = document.getElementById('saveSettingsBtn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        savePreviewSettings();
                    });
                }
            }
            
            // 줌 및 PDF 내보내기는 readonly 모드에서도 동작
            document.getElementById('exportPdfBtn')?.addEventListener('click', exportToPDF);
            document.getElementById('zoomInBtn')?.addEventListener('click', () => { currentZoom = Math.min(2, currentZoom + 0.1); updateZoom(); });
            document.getElementById('zoomOutBtn')?.addEventListener('click', () => { currentZoom = Math.max(0.5, currentZoom - 0.1); updateZoom(); });
            
            if (isReadonly) return; // readonly 모드에서는 나머지 이벤트 리스너 건너뛰기
            
            // 텍스트 변환 설정 이벤트 리스너
            const textFormatMode = document.getElementById('textFormatMode');
            const textDelimiter = document.getElementById('textDelimiter');
            const customDelimiter = document.getElementById('customDelimiter');
            const delimiterRow = document.getElementById('delimiterRow');
            
            if (textFormatMode) {
                textFormatMode.addEventListener('change', function() {
                    // 구분 기호 추가 모드일 때만 구분 기호 입력 표시
                    if (delimiterRow) {
                        delimiterRow.style.display = this.value === 'REPLACE' ? 'block' : 'none';
                    }
                    
                    // 설정 업데이트
                    window.textFormatConfig.mode = this.value;
                    
                    try {
                        localStorage.setItem('textFormatConfig', JSON.stringify(window.textFormatConfig));
                    } catch (e) {
                        console.error('설정 저장 실패:', e);
                    }
                    
                    // 텍스트 변환 설정 변경 로깅
                    if (typeof window.logPreviewAction === 'function') {
                        window.logPreviewAction('preview_text_transform');
                    }
                    
                    // 테이블 즉시 업데이트
                    if (window.currentLabelData && Object.keys(window.currentLabelData).length > 0) {
                        renderTable(window.currentLabelData);
                    }
                });
                
                // 초기 상태 설정
                if (delimiterRow) {
                    delimiterRow.style.display = textFormatMode.value === 'REPLACE' ? 'block' : 'none';
                }
            }
            
            if (textDelimiter && customDelimiter) {
                const customDelimiterGroup = document.getElementById('customDelimiterGroup');
                const applyCustomDelimiter = document.getElementById('applyCustomDelimiter');
                
                textDelimiter.addEventListener('change', function() {
                    if (this.value === 'custom') {
                        if (customDelimiterGroup) {
                            customDelimiterGroup.style.display = 'block';
                        }
                        customDelimiter.focus();
                    } else {
                        if (customDelimiterGroup) {
                            customDelimiterGroup.style.display = 'none';
                        }
                        
                        // 설정 업데이트
                        window.textFormatConfig.delimiter = this.value;
                        
                        try {
                            localStorage.setItem('textFormatConfig', JSON.stringify(window.textFormatConfig));
                        } catch (e) {
                            console.error('설정 저장 실패:', e);
                        }
                        
                        // 텍스트 변환 설정 변경 로깅
                        if (typeof window.logPreviewAction === 'function') {
                            window.logPreviewAction('preview_text_transform');
                        }
                        
                        // 테이블 즉시 업데이트
                        if (window.currentLabelData && Object.keys(window.currentLabelData).length > 0) {
                            renderTable(window.currentLabelData);
                        }
                    }
                });
                
                // 적용 버튼 클릭 이벤트
                if (applyCustomDelimiter) {
                    applyCustomDelimiter.addEventListener('click', function() {
                        const customValue = customDelimiter.value.trim();
                        if (!customValue) {
                            alert('구분 기호를 입력해주세요.');
                            customDelimiter.focus();
                            return;
                        }
                        
                        // 설정 업데이트
                        window.textFormatConfig.delimiter = customValue;
                        
                        try {
                            localStorage.setItem('textFormatConfig', JSON.stringify(window.textFormatConfig));
                        } catch (e) {
                            console.error('설정 저장 실패:', e);
                        }
                        
                        // 텍스트 변환 설정 변경 로깅
                        if (typeof window.logPreviewAction === 'function') {
                            window.logPreviewAction('preview_text_transform');
                        }
                        
                        // 테이블 즉시 업데이트
                        if (window.currentLabelData && Object.keys(window.currentLabelData).length > 0) {
                            renderTable(window.currentLabelData);
                        }
                    });
                }
                
                // Enter 키로도 적용 가능
                customDelimiter.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter' && applyCustomDelimiter) {
                        applyCustomDelimiter.click();
                    }
                });
            }
            
            // 페이지 로드 시 설정 불러오기
            try {
                const saved = localStorage.getItem('textFormatConfig');
                if (saved) {
                    const config = JSON.parse(saved);
                    
                    // window.textFormatConfig 업데이트
                    if (config.mode) {
                        window.textFormatConfig.mode = config.mode;
                    }
                    if (config.delimiter) {
                        window.textFormatConfig.delimiter = config.delimiter;
                    }
                    
                    // UI에 반영
                    if (textFormatMode && config.mode) {
                        textFormatMode.value = config.mode;
                        if (delimiterRow) {
                            delimiterRow.style.display = config.mode === 'REPLACE' ? 'block' : 'none';
                        }
                    }
                    if (config.delimiter) {
                        if (textDelimiter) {
                            // 미리 정의된 구분 기호인지 확인
                            const predefined = ['|', ',', '/', '·'];
                            if (predefined.includes(config.delimiter)) {
                                textDelimiter.value = config.delimiter;
                            } else {
                                textDelimiter.value = 'custom';
                                if (customDelimiter) {
                                    customDelimiter.value = config.delimiter;
                                    customDelimiter.style.display = 'block';
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.error('설정 불러오기 실패:', e);
            }
        }
    
        window.addEventListener('message', function(e) {
            if (e.data?.type === 'previewCheckedFields' && e.data.checked) {

                dataLoaded = true;
                checkedFields = e.data.checked;
                
                // 부모창에서 전달된 알레르기 데이터 저장 (전역)
                if (e.data.allergens && Array.isArray(e.data.allergens) && e.data.allergens.length > 0) {
                    window.parentAllergens = e.data.allergens;
                    window.allergensData = e.data.allergens;
                }
                
                // 맞춤항목이 있으면 customFieldsData에 병합
                if (e.data.customFields && e.data.customFields.length > 0) {
                    // 기존 customFieldsData를 상세모드에서 전달받은 데이터로 대체
                    customFieldsData.length = 0;
                    customFieldsData.push(...e.data.customFields);
                    // 전역으로 다시 설정
                    window.customFieldsData = customFieldsData;
                }
                
                renderTable(checkedFields);
                const frmlc = checkedFields.frmlc_mtrqlt || '';
                updateRecyclingMarkUI(frmlc);
                
                // Update footer with received date
                const updateDateTime = e.data.update_datetime || new Date().toISOString().slice(0, 16).replace('T', ' ');
                const footerInfo = document.querySelector('.footer-text .creator-info');
                if (footerInfo) footerInfo.textContent = `[${updateDateTime}]`;
            }
        });
    
        // Initial calls
        if (tbody) {
            tbody.innerHTML = `<tr><td colspan="2" style="text-align:center; padding: 20px; color: #6c757d;">표시사항 데이터를 기다리는 중...</td></tr>`;
        }

        let initialLabelData = null;
        try {
            const labelDataScript = document.getElementById('label-data');
            if (labelDataScript && labelDataScript.textContent) {
                initialLabelData = JSON.parse(labelDataScript.textContent);
            }
        } catch (e) {
            initialLabelData = null;
        }

        if (initialLabelData && Object.keys(initialLabelData).length > 0) {
            dataLoaded = true;
            checkedFields = initialLabelData;
            renderTable(checkedFields);
            const frmlc = checkedFields.frmlc_mtrqlt || '';
            updateRecyclingMarkUI(frmlc);
            /* initialLabelData로 1차 렌더 후, opener(팝업) 또는 parent(탭 iframe)에도 최신 데이터 요청
               → 알레르기 뱃지 / 원산지 굵기 처리 정상화 */
            const _previewTarget = window.opener || (window.self !== window.top ? window.parent : null);
            if (_previewTarget) {
                _previewTarget.postMessage({ type: 'requestPreviewData' }, '*');
            }
        } else {
            const _previewTarget2 = window.opener || (window.self !== window.top ? window.parent : null);
            if (_previewTarget2) {
                _previewTarget2.postMessage({ type: 'requestPreviewData' }, '*');
            }
        }

        setTimeout(() => {
            if (!dataLoaded) {

                const sampleData = { prdlst_nm: '샘플 제품', prdlst_dcnm: '과자', content_weight: '100g', frmlc_mtrqlt: '종이', pog_daycnt: '제조일로부터 12개월', rawmtrl_nm_display: '밀가루(밀:미국산), 설탕, 식물성유지', cautions: '이 제품은 우유, 대두를 사용한 제품과 같은 제조시설에서 제조하고 있습니다.', additional_info: '부정불량식품 신고는 국번없이 1399' };
                renderTable(sampleData);
                
                // 초기 로드 후 면적 계산을 위해 추가 업데이트 실행
                setTimeout(() => {
                    updatePreviewStyles();
                }, 100);
                updateRecyclingMarkUI(sampleData.frmlc_mtrqlt);
            }
        }, 2000);

        // 페이지 언로드 시 현재 설정을 자동 저장 (세션 스토리지에만)
        window.addEventListener('beforeunload', function() {
            try {
                // 여러 방법으로 labelId 찾기
                let labelId = document.querySelector('input[name="label_id"]')?.value;
                if (!labelId) {
                    const urlParams = new URLSearchParams(window.location.search);
                    labelId = urlParams.get('label_id');
                }
                if (!labelId) return;
                
                const recyclingMarkInfo = getCurrentRecyclingMarkInfo();
                const currentSettings = {
                    label_id: labelId,
                    width: parseFloat(widthInput?.value) || 10,
                    font: fontFamilySelect?.value || "'Noto Sans KR'",
                    font_size: parseFloat(fontSizeInput?.value) || 10,
                    letter_spacing: parseInt(letterSpacingInput?.value) || -5,
                    line_spacing: parseFloat(lineHeightInput?.value) || 1.5,
                    recycling_mark: recyclingMarkInfo,
                    auto_saved: true,
                    timestamp: new Date().toISOString()
                };
                
                sessionStorage.setItem('labelPreviewSettings_' + labelId, JSON.stringify(currentSettings));

            } catch (e) {
                console.warn('설정 자동 저장 실패:', e);
            }
        });
        
        setupEventListeners();
        renderRecyclingMarkUI();
        restoreActiveTab(); // 탭 상태 복원
        
        // 필드 순서 조정 기능 초기화
        if (typeof window.initializeFieldOrder === 'function') {
            window.initializeFieldOrder();
        } else {
            console.error('initializeFieldOrder 함수를 찾을 수 없습니다!');
        }
        
        // 초기 스타일 적용 및 면적 계산
        updatePreviewStyles();
        
        // 저장된 설정 로드
        loadSavedPreviewSettings();
        
        // 페이지 로드 완료 후 최종 면적 계산
        setTimeout(() => {
            updatePreviewStyles();
        }, 500);
    });

    // 프론트엔드 상수들은 constants.js에서 로드됨
  </script>
</body>
</html>
