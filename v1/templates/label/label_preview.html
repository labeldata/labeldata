{% load static %}
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>라벨 미리보기</title>
  <!-- External Libraries -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700&family=Nanum+Myeongjo:wght@400;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --modern-primary: #3b82f6;
      --modern-success: #10b981;
      --modern-gray-200: #e5e7eb;
      --modern-border-radius-sm: 6px;
    }

    body {
        font-family: 'Noto Sans KR', sans-serif;
        background-color: #f8f9fa;
        margin: 0;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .preview-page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      border-bottom: 1px solid var(--modern-gray-200);
      background-color: #ffffff;
      height: 70px;
      flex-shrink: 0;
    }
    .preview-page-header .panel-title { 
        font-size: 1.25rem; 
        font-weight: 600; 
        color: #333; 
        margin: 0;
    }
    .preview-actions { display: flex; gap: 8px; align-items: center; }

    .preview-container {
      display: flex;
      flex-grow: 1;
      overflow: hidden;
    }

    .settings-panel {
      width: 420px; /* 너비 소폭 증가 */
      padding: 20px;
      border-right: 1px solid #dee2e6;
      overflow-y: auto;
      background-color: #ffffff;
      flex-shrink: 0;
    }

    .preview-panel {
      flex-grow: 1;
      padding: 20px;
      overflow: auto;
      background-color: #f0f2f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    #previewContent {
      background: white;
      border: 1px solid #dee2e6;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 20px;
      box-sizing: content-box;
      transform-origin: top center;
      transition: transform 0.2s ease-in-out;
      position: relative;
    }
    .preview-header-box { 
        background-color: #023047; 
        color: #ffffff; 
        padding: 8px 12px; 
        margin: -20px -20px 10px -20px;
    }
    .preview-header-box .header-text { margin: 0; line-height: 1.2; font-weight: bold; font-size: 10pt; text-align: center; }
    .preview-table { width: 100%; border-collapse: collapse; table-layout: auto; word-break: break-all; }
    .preview-table th, .preview-table td { border: 1px solid #dee2e6; padding: 4px 8px; vertical-align: middle; font-size: 10pt; }
    .preview-table th { 
        background-color: #f8f9fa; 
        text-align: center; 
        font-weight: 500; 
        white-space: nowrap; 
        width: 1%;
    }
    .footer-text { text-align: right; font-size: 7.5pt; color: #6c757d; margin-top: 12px; padding-top: 8px; border-top: 1px solid #eee; }

    .settings-group { margin-bottom: 25px; }
    .settings-actions-row { display: flex; gap: 10px; margin-bottom: 20px; }
    
    /* 2개씩 묶기 위한 스타일 */
    .settings-row-pair {
        display: flex;
        gap: 15px;
        margin-bottom: 15px;
    }
    .settings-row-pair .settings-row {
        flex: 1;
        margin-bottom: 0;
    }

    .settings-row { margin-bottom: 15px; }
    .form-label { font-weight: 500; margin-bottom: 5px; font-size: 0.9rem; }
    .form-label.required::after { content: " *"; color: #dc3545; }
    #heightInput { background-color: #e9ecef !important; cursor: not-allowed !important; }

    .zoom-controls { display: flex; align-items: center; gap: 8px; }
    .zoom-controls button { width: 32px; height: 32px; font-size: 1rem; }
    #zoomDisplay { font-weight: 500; min-width: 50px; text-align: center; }
    
    #recyclingMarkUiBox {
        border-top: 1px solid #e9ecef;
        margin-top: 1.5rem;
        padding-top: 1.5rem;
    }
    #recyclingMarkControls { width: 100%; }
    #recyclingMarkContainer { 
        position: absolute; 
        width: 60px; 
        cursor: move; 
        text-align: center; 
        top: 20px; 
        right: 20px; 
        z-index: 10; 
    }
    #recyclingMarkContainer .recycling-mark-image { width: 100%; height: auto; display: block; }
    #recyclingMarkContainer .recycling-mark-text { margin-top: 4px; }
    .recycling-text-line { 
        font-weight: 500; 
        color: #000; 
        line-height: 1.1; 
        word-break: keep-all; 
        white-space: nowrap; 
        overflow: hidden; 
        text-overflow: ellipsis; 
        display: inline-block; 
    }

    .modal-body {
        max-height: 70vh;
        overflow-y: auto;
    }
  </style>
</head>
<body>
  <header class="preview-page-header">
    <h1 class="panel-title">라벨 미리보기</h1>
    <div class="preview-actions" role="toolbar" aria-label="미리보기 도구">
      <div class="zoom-controls">
        <button class="btn btn-outline-secondary btn-sm" id="zoomOutBtn" aria-label="축소"><i class="fas fa-search-minus"></i></button>
        <span id="zoomDisplay">100%</span>
        <button class="btn btn-outline-secondary btn-sm" id="zoomInBtn" aria-label="확대"><i class="fas fa-search-plus"></i></button>
      </div>
      <button class="btn btn-info btn-sm" id="validateButton" aria-label="규정 검증">
        <i class="fas fa-check-circle me-1" aria-hidden="true"></i>규정 검증
      </button>
      <button class="btn btn-primary btn-sm" id="exportPdfBtn" aria-label="PDF 저장">
        <i class="fas fa-file-pdf me-1" aria-hidden="true"></i>PDF 저장
      </button>
      <button class="btn btn-secondary btn-sm" onclick="window.close()" aria-label="창 닫기">
        <i class="fas fa-times me-1" aria-hidden="true"></i>닫기
      </button>
    </div>
  </header>

  <main class="preview-container">
    <aside class="settings-panel">
      <div class="settings-actions-row">
        <button class="btn btn-sm btn-outline-secondary" id="resetSettingsBtn">
          <i class="fas fa-undo me-1"></i> 설정 초기화
        </button>
        <button id="saveSettingsBtn" class="btn btn-sm btn-success">
          <i class="fas fa-save me-1"></i> 설정 저장
        </button>
      </div>
      
      <section class="settings-group">
        <div class="settings-row-pair">
          <div class="settings-row">
              <label class="form-label required" for="widthInput">가로 (cm)</label>
              <input type="number" class="form-control form-control-sm" id="widthInput" value="10" min="4" max="50" step="1">
          </div>
          <div class="settings-row">
              <label class="form-label">세로 (cm) - 자동 계산</label>
              <input type="text" class="form-control form-control-sm" id="heightInput" readonly>
          </div>
        </div>
        <div class="settings-row-pair">
          <div class="settings-row">
              <label class="form-label" for="fontFamilySelect">글꼴</label>
              <select class="form-select form-select-sm" id="fontFamilySelect">
                <option value="'Noto Sans KR', sans-serif" selected>노토 산스</option>
                <option value="'Nanum Gothic', sans-serif">나눔고딕</option>
                <option value="'Nanum Myeongjo', serif">나눔명조</option>
              </select>
          </div>
          <div class="settings-row">
              <label class="form-label" for="fontSizeInput">기본 글자 크기 (pt)</label>
              <input type="number" class="form-control form-control-sm" id="fontSizeInput" value="10" min="7" max="72" step="0.5">
          </div>
        </div>
        <div class="settings-row-pair">
            <div class="settings-row">
                <label class="form-label" for="letterSpacingInput">자간 (%)</label>
                <input type="number" class="form-control form-control-sm" id="letterSpacingInput" value="-5" min="-20" max="20" step="1">
            </div>
            <div class="settings-row">
                <label class="form-label" for="lineHeightInput">줄간격</label>
                <input type="number" class="form-control form-control-sm" id="lineHeightInput" value="1.5" min="1" max="3.0" step="0.1">
            </div>
        </div>
      </section>
      <div id="recyclingMarkUiBox" class="mt-4 pt-3 border-top"></div>
    </aside>

    <section class="preview-panel">
      <div id="previewContent">
        <div class="preview-header-box">
          <p class="header-text">식품 등의 표시·광고에 관한 법률에 의한 한글표시사항</p>
        </div>
        <table class="preview-table">
          <tbody id="previewTableBody">
             <!-- Data will be rendered here by JavaScript -->
          </tbody>
        </table>
        <div class="footer-text">
          ezlabel.com 에서 관련법규에 따라 작성되었습니다.
          <span class="creator-info"></span>
        </div>
      </div>
    </section>
  </main>

  <!-- Hidden data passed from backend -->
  <script id="preview-settings-data" type="application/json">
    {{ preview_settings|safe }}
  </script>
  <script id="country-mapping-data" type="application/json">{{ country_mapping|safe }}</script>
  <script id="country-list-data" type="application/json">{{ country_list|safe }}</script>
  <script id="expiry-recommendation-data" type="application/json">{{ expiry_recommendation|safe }}</script>
  <input type="hidden" id="update_datetime" value="{{ label.update_datetime|date:'Y-m-d H:i' }}">
  <input type="hidden" name="label_id" value="{{ label.label_id }}">
  <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">

  <!-- External JS Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  
  <script>
    document.addEventListener('DOMContentLoaded', function () {
        // --- DATA LOADING & STATE ---
        let countryMapping = {};
        let countryList = [];
        let checkedFields = {};
        let dataLoaded = false;
        let currentZoom = 1;
        let recyclingTextIdCounter = 0;
        let cachedValidation = null;

        function safeJsonParse(elementId) {
            try {
                const element = document.getElementById(elementId);
                if (element && element.textContent.trim()) {
                    // Django template sometimes adds quotes around the JSON string.
                    const text = element.textContent.trim();
                    return JSON.parse(text);
                }
            } catch (e) {
                console.error(`"${elementId}" 데이터 파싱 오류:`, e, "콘텐츠:", document.getElementById(elementId)?.textContent);
            }
            return {};
        }

        countryMapping = safeJsonParse('country-mapping-data');
        countryList = safeJsonParse('country-list-data') || [];

        // --- DOM ELEMENTS ---
        const previewContent = document.getElementById('previewContent');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const letterSpacingInput = document.getElementById('letterSpacingInput');
        const lineHeightInput = document.getElementById('lineHeightInput');
        const fontFamilySelect = document.getElementById('fontFamilySelect');
        const tbody = document.getElementById('previewTableBody');
        
        const DEFAULT_SETTINGS = {
            width: 10,
            fontSize: 10,
            letterSpacing: -5,
            lineHeight: 1.5,
            fontFamily: "'Noto Sans KR', sans-serif"
        };
        const REGULATIONS = {
            area_thresholds: { small: 100, medium: 3000, large: 3000 },
            font_size: { product_name: { min: 16, small_area_min: 10 }, origin: { min: 14, small_area_min: 10 }, content_weight: { min: 12, small_area_min: 10 }, general: { min: 10, small_area_min: 10 } },
            food_type_phrases: { "과ㆍ채가공품(살균제품/산성통조림)": ["캔주의"], "유함유가공품": ["알레르기 주의"], "고카페인": ["어린이, 임산부, 카페인 민감자는 섭취에 주의"], "젤리/곤약": ["질식주의"], "방사선 조사": ["감마선/전자선으로 조사처리"], "냉동식품": ["해동 후 재냉동 금지"] },
            expiry_recommendation: safeJsonParse('expiry-recommendation-data')
        };
        
        const recyclingMarkGroups = [
            { 
                group: '플라스틱', 
                options: [ 
                    { value: '무색페트', label: '무색페트', img: "{% static 'img/recycle_clearpet.png' %}" }, 
                    { value: '유색페트', label: '유색페트', img: "{% static 'img/recycle_pet.png' %}" },
                    { value: '플라스틱(PET)', label: '플라스틱(PET)', img: "{% static 'img/recycle_pet.png' %}" }, 
                    { value: '플라스틱(HDPE)', label: '플라스틱(HDPE)', img: "{% static 'img/recycle_hdpe.png' %}" },
                    { value: '플라스틱(LDPE)', label: '플라스틱(LDPE)', img: "{% static 'img/recycle_ldpe.png' %}" },
                    { value: '플라스틱(PP)', label: '플라스틱(PP)', img: "{% static 'img/recycle_pp.png' %}" },
                    { value: '플라스틱(PS)', label: '플라스틱(PS)', img: "{% static 'img/recycle_ps.png' %}" },
                    { value: '기타플라스틱', label: '기타플라스틱', img: "{% static 'img/recycle_other_plastic.png' %}" }
                ]
            },
            { 
                group: '종이/금속/유리', 
                options: [ 
                    { value: '종이', label: '종이', img: "{% static 'img/recycle_paper.png' %}" }, 
                    { value: '일반팩', label: '일반팩', img: "{% static 'img/recycle_pack_general.png' %}" },
                    { value: '멸균팩', label: '멸균팩', img: "{% static 'img/recycle_pack_sterile.png' %}" },
                    { value: '캔류(알미늄)', label: '캔류(알미늄)', img: "{% static 'img/recycle_can_aluminum.png' %}" },
                    { value: '캔류(철)', label: '캔류(철)', img: "{% static 'img/recycle_can_iron.png' %}" },
                    { value: '유리', label: '유리', img: "{% static 'img/recycle_glass.png' %}" }
                ]
            },
            { 
                group: '기타/혼합', 
                options: [ 
                    { value: '복합재질', label: '복합재질', img: "{% static 'img/recycle_coated.png' %}", isComposite: true },
                    { value: '비닐(PET)', label: '비닐(PET)', img: "{% static 'img/recycle_vinyl_pet.png' %}" },
                    { value: '비닐(HDPE)', label: '비닐(HDPE)', img: "{% static 'img/recycle_vinyl_hdpe.png' %}" },
                    { value: '비닐(LDPE)', label: '비닐(LDPE)', img: "{% static 'img/recycle_vinyl_ldpe.png' %}" },
                    { value: '비닐(PP)', label: '비닐(PP)', img: "{% static 'img/recycle_vinyl_pp.png' %}" },
                    { value: '비닐(PS)', label: '비닐(PS)', img: "{% static 'img/recycle_vinyl_ps.png' %}" },
                    { value: '비닐(기타)', label: '비닐(기타)', img: "{% static 'img/recycle_vinyl_other.png' %}" }
                ]
            }
        ];
        const recyclingMarkMap = {};
        recyclingMarkGroups.forEach(g => g.options.forEach(o => recyclingMarkMap[o.value] = o));
        const CM_TO_PX = 37.795;

        // --- UTILS ---
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            element.onmousedown = e => {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = () => { document.onmouseup = null; document.onmousemove = null; };
                document.onmousemove = e => {
                    e.preventDefault();
                    pos1 = pos3 - e.clientX;
                    pos2 = pos4 - e.clientY;
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    element.style.top = `${element.offsetTop - pos2}px`;
                    element.style.left = `${element.offsetLeft - pos1}px`;
                };
            };
        }

        // --- CORE FUNCTIONS ---
        function updatePreviewStyles() {
            if (!previewContent) return;
            const widthCm = parseFloat(widthInput.value) || 10;
            const fontSizePt = parseFloat(fontSizeInput.value) || 10;
            const letterSpacingPercent = parseInt(letterSpacingInput.value) || 0;
            const lineHeight = parseFloat(lineHeightInput.value) || 1.5;
            const fontFamily = fontFamilySelect.value;
            
            previewContent.style.width = `${widthCm * CM_TO_PX}px`;
            
            const elementsToStyle = previewContent.querySelectorAll('th, td, .header-text, .footer-text, .recycling-text-line');
            elementsToStyle.forEach(el => {
                el.style.fontSize = `${fontSizePt}pt`;
                el.style.fontFamily = fontFamily;
                el.style.letterSpacing = `${letterSpacingPercent / 100}em`;
                el.style.lineHeight = lineHeight;
            });

            requestAnimationFrame(() => {
                if(previewContent.scrollHeight > 0){
                    const contentHeightPx = previewContent.scrollHeight;
                    const heightCm = (contentHeightPx / CM_TO_PX).toFixed(1);
                    heightInput.value = `${heightCm} cm`;
                }
            });
        }
        
        function convertCountryCodeToKorean(text) {
            if (!text || !countryMapping) return text;
            return text.replace(/\b[A-Z]{2}\b/g, match => countryMapping[match] || match);
        }

        function boldCountryNames(text, countries) {
            if (!text || !countries || countries.length === 0) return text;
            let processedText = text;
            const sortedCountries = countries.sort((a, b) => b.length - a.length);
            sortedCountries.forEach(country => {
                if(country){
                    const regex = new RegExp(`(${country.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\s*산)?)`, 'gi');
                    processedText = processedText.replace(regex, '<strong>$1</strong>');
                }
            });
            return processedText;
        }

        function renderTable(data) {
            if (!tbody) return;
            tbody.innerHTML = '';
            
            // 항목 순서를 표시사항 작성 페이지와 일치시키기 위한 정렬된 필드 목록
            const ORDERED_FIELDS = [
                'prdlst_nm', 'ingredient_info', 'prdlst_dcnm', 
                'prdlst_report_no', 'content_weight', 'country_of_origin',
                'storage_method', 'frmlc_mtrqlt', 'bssh_nm',
                'rawmtrl_nm_display', 'cautions', 'additional_info'
                // 'distributor_address', 'repacker_address', 'importer_address', 
                // 'pog_daycnt', 'weight_calorie', 'nutrition_text'
            ];
            
            const FIELD_LABELS = { 
                prdlst_dcnm: '식품유형', 
                prdlst_nm: '제품명', 
                ingredient_info: '특정성분 함량',
                content_weight: '내용량', 
                weight_calorie: '내용량(열량)',
                prdlst_report_no: '품목보고번호',
                country_of_origin: '원산지', 
                storage_method: '보관 방법', 
                frmlc_mtrqlt: '용기·포장재질',
                bssh_nm:'제조원 소재지',
                distributor_address: '유통전문판매원', 
                repacker_address: '소분원', 
                importer_address: '수입원',
                pog_daycnt: '소비기한', 
                rawmtrl_nm_display: '원재료명', 
                cautions: '주의사항',
                additional_info: '기타표시사항',
                nutrition_text: '영양성분'
            };

            // 정렬된 순서대로 필드 표시
            ORDERED_FIELDS.forEach(key => {
                if (data[key]) {
                    const tr = document.createElement('tr');
                    const th = document.createElement('th');
                    const td = document.createElement('td');
                    th.textContent = FIELD_LABELS[key] || key;
                    
                    let value = data[key];

                    if (key === 'rawmtrl_nm_display') {
                        const allergenMatch = value.match(/\[알레르기 성분\s*:\s*([^\]]+)\]/);
                        const gmoMatch = value.match(/\[GMO\s*성분\s*:\s*([^\]]+)\]/);
                        const container = document.createElement('div');
                        let mainText = value.replace(/\[알레르기 성분\s*:[^\]]+\]/, '').replace(/\[GMO\s*성분\s*:[^\]]+\]/, '').trim() || '';
                        
                        let processedText = boldCountryNames(mainText, countryList);
                        container.innerHTML = `<div>${processedText}</div>`;

                        if (allergenMatch) {
                            container.innerHTML += `<div style="background-color: #000; color: #fff; padding: 2px 5px; font-weight: bold; display: inline-block; margin-top: 5px;">${allergenMatch[1].trim()} 함유</div>`;
                        }
                         if (gmoMatch) {
                            container.innerHTML += `<div style="background-color: #000; color: #fff; padding: 2px 5px; font-weight: bold; display: inline-block; margin-top: 5px;">${gmoMatch[1].trim()}(GMO)</div>`;
                        }
                        td.appendChild(container);

                    } else if (key === 'country_of_origin'){
                         td.innerHTML = boldCountryNames(convertCountryCodeToKorean(value), countryList);
                    }
                    else {
                        td.innerHTML = boldCountryNames(value, countryList);
                    }
                    tr.appendChild(th);
                    tr.appendChild(td);
                    tbody.appendChild(tr);
                }
            });
            updatePreviewStyles();
        }

        // [추가] 분리배출 마크에 텍스트 라인 추가
        function addTextToRecyclingMark(text) {

            const container = document.getElementById('recyclingMarkContainer');
            const image = document.getElementById('recyclingMarkImage') || container.querySelector('.recycling-mark-image');
            const textContainer = container.querySelector('.recycling-mark-text');
            if (!container || !image || !textContainer) {

                return;
            }



            const textDiv = document.createElement('div');
            textDiv.className = 'recycling-text-line';
            textDiv.dataset.textId = `rtext-${++recyclingTextIdCounter || 1}`;
            textDiv.textContent = text;
            

            textDiv.style.cssText = `
                font-weight: 500;
                color: #000;
                line-height: 1;
                word-break: keep-all;
                text-align: center;
                margin-top: 0px;
            `;
            textContainer.appendChild(textDiv);

            // 폰트 크기 자동 조절
            const imageWidth = image.offsetWidth;
            let fontSize = 6; // pt 단위
            textDiv.style.fontSize = `${fontSize}pt`;

            // 텍스트 너비가 이미지 너비보다 크면 폰트 크기를 줄임
            while (textDiv.scrollWidth > imageWidth && fontSize > 4) {
                fontSize -= 0.5;
                textDiv.style.fontSize = `${fontSize}pt`;
            }
        }
        
        // [수정] 미리보기 영역에 마크(이미지+텍스트) 추가 및 드래그
        function setRecyclingMark(markValue, auto = false) {
            const markObj = recyclingMarkMap[markValue];
            const previewContent = document.getElementById('previewContent');
            if (!previewContent || !markObj) return;

            // 컨테이너를 찾거나 새로 생성
            let container = document.getElementById('recyclingMarkContainer');
            if (container) container.remove(); // 기존 컨테이너가 있으면 제거하고 새로 생성

            container = document.createElement('div');
            container.id = 'recyclingMarkContainer';
            container.style.position = 'absolute';
            container.style.width = '60px'; // 컨테이너 너비 고정
            container.style.cursor = 'move';
            container.style.textAlign = 'center';
            
            // 컨테이너 내부에 이미지와 텍스트 영역 추가
            container.innerHTML = `
                <img id="recyclingMarkImage" class="recycling-mark-image" src="${markObj.img}" alt="${markObj.label}" style="width: 100%; height: auto; display: block; margin-bottom: -3px;">
                <div class="recycling-mark-text" style="margin-top: 0; padding-top: 0;"></div>
            `;
            previewContent.appendChild(container);

            // [수정] 자동 위치 설정: 제품명 행의 우측 상단에 배치
            const thElements = previewContent.querySelectorAll('th');
            let productNameRow = null;
            thElements.forEach(th => {
                if (th.textContent.trim() === '제품명') {
                    productNameRow = th.parentElement; // <tr> element
                }
            });

            if (productNameRow) {
                const previewRect = previewContent.getBoundingClientRect();
                const rowRect = productNameRow.getBoundingClientRect();
                
                // 제품명 행의 상단에 맞춤
                const topPosition = rowRect.top - previewRect.top;
                
                container.style.top = `${topPosition}px`;
                container.style.right = '25px'; // 우측 여백
                container.style.left = '';
                container.style.bottom = '';
            } else {
                // 제품명 행을 찾지 못할 경우의 기본 위치 (예: 우측 하단)
                container.style.right = '20px';
                container.style.bottom = '20px';
                container.style.left = '';
                container.style.top = '';
            }

            // 드래그 가능하게 설정
            container.style.position = 'absolute';
            if (container.style.top === '' && container.style.left === '') {
                container.style.top = '10px';
                container.style.left = '10px';
            }
            makeDraggable(container);
            container.ondragstart = () => false;
        }
        
        function renderRecyclingMarkUI() {
            const target = document.getElementById('recyclingMarkUiBox');
            if (!target || document.getElementById('recyclingMarkControls')) return;

            target.innerHTML = `
                <section class="settings-group">
                    <h6 class="mb-3">분리배출마크</h6>
                    <div id="recyclingMarkControls">
                        <div class="settings-row-pair">
                            <div class="settings-row">
                                <label class="form-label" for="recyclingMarkSelect">분리배출마크 선택</label>
                                <select class="form-select form-select-sm" id="recyclingMarkSelect">
                                    <option value="">마크를 선택하세요</option>
                                    ${recyclingMarkGroups.map(group => 
                                        `<optgroup label="${group.group}">
                                            ${group.options.map(option => 
                                                `<option value="${option.value}" ${option.isComposite ? 'data-is-composite="true"' : ''}>${option.label}</option>`
                                            ).join('')}
                                        </optgroup>`
                                    ).join('')}
                                </select>
                            </div>
                            <div class="settings-row d-flex align-items-end">
                                <button class="btn btn-outline-primary btn-sm w-100" id="addRecyclingMarkBtn">
                                    <i class="fas fa-plus me-1"></i>추가
                                </button>
                            </div>
                        </div>
                        <div id="additionalTextInputBox" style="display: none;" class="mt-3">
                            <div class="settings-row-pair">
                                <div class="settings-row">
                                    <label class="form-label" for="additionalRecyclingText">복합재질 정보</label>
                                    <input type="text" class="form-control form-control-sm" 
                                           id="additionalRecyclingText" 
                                           placeholder="예: 몸체(종이)/뚜껑(PP)">
                                </div>
                                <div class="settings-row d-flex align-items-end">
                                    <button class="btn btn-outline-success btn-sm w-100" id="addRecyclingTextBtn">
                                        <i class="fas fa-check me-1"></i>추가
                                    </button>
                                </div>
                            </div>
                            <div class="form-text mt-1">여러 재질은 '/'로 구분하여 입력하세요</div>
                        </div>
                    </div>
                </section>
            `;
            
            const select = document.getElementById('recyclingMarkSelect');
            const addBtn = document.getElementById('addRecyclingMarkBtn');
            const additionalInputBox = document.getElementById('additionalTextInputBox');

            select.addEventListener('change', function() {
                const selectedOption = this.options[this.selectedIndex];
                if (selectedOption.dataset.isComposite === 'true') {
                    additionalInputBox.style.display = 'block';
                } else {
                    additionalInputBox.style.display = 'none';
                }
            });
            
            addBtn.addEventListener('click', () => {
                const selectedOption = select.options[select.selectedIndex];
                const markValue = selectedOption.value;
                if (!markValue) { alert('마크를 선택해주세요.'); return; }
                
                if (addBtn.textContent === '추가') {
                    setRecyclingMark(markValue);
                    addBtn.textContent = '제거';
                    addBtn.classList.replace('btn-outline-primary', 'btn-danger');
                    if (selectedOption.dataset.isComposite === 'true') {
                        additionalInputBox.style.display = 'block';
                        // 복합재질 선택 시 자동 포커스
                        document.getElementById('additionalRecyclingText').focus();
                    }
                } else {
                    const mark = document.getElementById('recyclingMarkContainer');
                    if (mark) mark.remove();
                    addBtn.textContent = '추가';
                    addBtn.classList.replace('btn-danger', 'btn-outline-primary');
                    select.value = "";
                    additionalInputBox.style.display = 'none';
                }
            });

            const addTextBtn = document.getElementById('addRecyclingTextBtn');
            addTextBtn.addEventListener('click', () => {
                const textInput = document.getElementById('additionalRecyclingText');
                const text = textInput.value.trim();

                
                if (text) {
                    // 기존 텍스트 라인 모두 제거 (복합재질은 덮어쓰기 방식으로)
                    const textContainer = document.querySelector('#recyclingMarkContainer .recycling-mark-text');
                    if (textContainer) {
                        // recyclingTextIdCounter 재설정 (ID 충돌 방지)
                        window.recyclingTextIdCounter = 0;
                        textContainer.innerHTML = '';
                    }
                    
                    // 각 줄을 개별 라인으로 분리하여 추가
                    const lines = text.split('/');
                    lines.forEach((line, index) => {
                        const trimmedLine = line.trim();
                        if (trimmedLine) {
                            addTextToRecyclingMark(trimmedLine);
                        }
                    });
                    
                    // 입력 필드에 값 보존 (저장 시 참조하기 위해)
                    textInput.value = text;
                    textInput.focus(); // 텍스트 추가 후 다시 포커스
                }
            });
            
            // 엔터키로 텍스트 추가 가능하도록
            document.getElementById('additionalRecyclingText')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addTextBtn.click();
                }
            });
        }
        
        function updateZoom() {
            previewContent.style.transform = `scale(${currentZoom})`;
            document.getElementById('zoomDisplay').textContent = `${Math.round(currentZoom * 100)}%`;
        }
    
        function resetSettings() {
            widthInput.value = DEFAULT_SETTINGS.width;
            fontSizeInput.value = DEFAULT_SETTINGS.fontSize;
            letterSpacingInput.value = DEFAULT_SETTINGS.letterSpacing;
            lineHeightInput.value = DEFAULT_SETTINGS.lineHeight;
            fontFamilySelect.value = DEFAULT_SETTINGS.fontFamily;
            updatePreviewStyles();
        }

        // --- All validation functions from the JS file ---
        // 농수산물 목록
        const farmSeafoodItems = [
        "쌀", "찹쌀", "현미", "벼", "밭벼", "찰벼", "보리", "보리쌀", "밀", "밀쌀", "호밀", "귀리", "옥수수", "조", "수수", "메밀", "기장", "율무",
        "콩", "팥", "녹두", "완두", "강낭콩", "동부", "기타콩",
        "감자", "고구마", "야콘",
        "참깨", "들깨", "땅콩", "해바라기", "유채", "고추씨",
        "수박", "참외", "메론", "딸기", "토마토", "방울토마토", "호박", "오이",
        "배추", "양배추", "고구마줄기", "토란줄기", "쑥", "건 무청", "시래기", "무말랭이", "무", "알타리무", "순무", "당근", "우엉", "연근", "양파", "대파", "쪽파", "실파",
        "건고추", "마늘", "생강", "풋고추", "꽈리고추", "홍고추", "피망", "단고추", "브로코리", "녹색꽃양배추", "파프리카",
        "갈근", "감초", "강활", "건강", "결명자", "구기자", "금은화", "길경", "당귀", "독활", "두충", "만삼", "맥문동", "모과", "목단", "반하", "방풍", "복령", "복분자", "백수오", "백지", "백출", "비자", "사삼", "양유", "더덕", "산수유", "산약", "산조인", "산초", "소자", "시호", "오가피", "오미자", "오배자", "우슬", "황정", "층층갈고리둥굴레", "옥죽", "외유", "둥굴레", "음양곽", "익모초", "작약", "진피", "지모", "지황", "차전자", "창출", "천궁", "천마", "치자", "택사", "패모", "하수오", "황기", "황백", "황금", "행인", "향부자", "현삼", "후박", "홍화씨", "고본", "소엽", "형개", "치커리", "헛개",
        "녹용", "녹각",
        "사과", "애플", "배", "포도", "복숭아", "단감", "떫은감", "곶감", "자두", "살구", "참다래", "파인애플", "감귤", "만감", "한라봉", "레몬", "탄제린", "오렌지", "청견", "자몽", "금감", "유자", "버찌", "매실", "앵두", "무화과", "바나나", "블루베리", "석류", "오디",
        "밤", "대추", "잣", "호두", "은행", "도토리",
        "영지버섯", "팽이버섯", "목이버섯", "석이버섯", "운지버섯", "송이버섯", "표고버섯", "양송이버섯", "느타리버섯", "상황버섯", "아가리쿠스", "동충하초", "새송이버섯", "싸리버섯", "능이버섯",
        "수삼", "산양삼", "장뇌삼", "산삼배양근", "묘삼",
        "고사리", "취나물", "고비", "두릅", "죽순", "도라지", "더덕", "마",
        "쇠고기", "한우", "육우", "젖소", "양고기", "염소", "돼지고기", "멧돼지", "닭고기", "오리고기", "사슴고기", "토끼고기", "칠면조고기", "메추리고기", "말고기", "육류의 부산물",
        "국화", "카네이션", "장미", "백합", "글라디올러스", "튜울립", "거베라", "아이리스", "프리지아", "칼라", "안개꽃",
        "벌꿀", "건조누에", "프로폴리스",
        "계란", "오리알", "메추리알",
        "뽕잎", "누에번데기", "초콜릿", "치즈",
        "고등어", "명태", "갈치", "조기", "참치", "연어", "대구", "방어", "참돔", "새우", "오징어", "낙지", "홍합", "바지락", "전복", "게",
        "다시마", "미역", "김", "톳", "매생이", "어묵", "가리비 관자"
        ];

        // 사용금지 문구
        const forbiddenPhrases = ['천연', '자연', '슈퍼', '생명'];

        // [수정] 제품명 성분 표시 검증 로직 (checkFarmSeafoodCompliance)
        function checkFarmSeafoodCompliance() {
            const errors = [];
            const suggestions = [];
            const productName = checkedFields.prdlst_nm || '';
            const ingredientInfo = checkedFields.ingredient_info || '';

            // 제품명에 포함된 농수산물명 추출 (긴 이름부터 처리하여 '돼지고기'가 '고기'보다 먼저 잡히도록 함)
            const foundItems = farmSeafoodItems
                .filter(item => productName.includes(item))
                .sort((a, b) => b.length - a.length);

            if (foundItems.length === 0) {
                return { errors: [], suggestions: [] }; // 검증 대상이 없으면 종료
            }

            foundItems.forEach(item => {
                // '특정성분 함량' 필드에 해당 성분명과 함량(%)이 모두 포함되어 있는지 확인
                // 정규식: 성분명 + (0개 이상의 문자, 단 쉼표 제외) + 숫자 + %
                // 예: "사과 100%", "사과(국산) 100%" 모두 통과
                const complianceRegex = new RegExp(`${item}[^,]*\\d+(\\.\\d+)?\\s*%`);

                // 검증 실패 시 오류 추가
                if (!complianceRegex.test(ingredientInfo)) {
                    errors.push(`제품명에 사용된 '${item}'의 함량을 '특정성분 함량' 항목에 표시하세요 (예: ${item} 100%).`);
                }
            });

            return { errors, suggestions };
        }
        
        // 2. 알레르기 성분 중복: 중복된 성분을 모두 한 줄에 표시
        function checkAllergenDuplication() {
            const errors = [];
            const suggestions = [];
            const rawmtrl = checkedFields.rawmtrl_nm_display || '';
            const cautions = checkedFields.cautions || '';
            const allergenMatch = rawmtrl.match(/\[알레르기 성분\s*:\s*([^\]]+)\]/i);
            if (allergenMatch) {
                const allergens = allergenMatch[1].split(',').map(a => a.trim().toLowerCase());
                const cautionsLower = cautions.toLowerCase();
                const finalDuplicatedMessages = [];

                // 일반 알레르기 성분 및 '알류' 포함하여 한번에 검사
                allergens.forEach(allergen => {
                    if (allergen === '알류') {
                        const eggRelatedTerms = ['알류', '난류', '계란', '메츄리알', '오리알', '달걀'];
                        const foundEggTerms = eggRelatedTerms.filter(term => cautionsLower.includes(term));

                        if (foundEggTerms.length > 0) {
                            finalDuplicatedMessages.push(`알류(${foundEggTerms.join(', ')})`);
                        }
                    } else {
                        if (cautionsLower.includes(allergen)) {
                            finalDuplicatedMessages.push(allergen);
                        }
                    }
                });

                if (finalDuplicatedMessages.length > 0) {
                    errors.push(`주의사항에 원재료명의 알레르기 성분이 중복 표시되었습니다: ${finalDuplicatedMessages.join(', ')}`);
                }
            }
            return { errors, suggestions };
        }

        // 3. 냉동식품 문구 및 온도, 보관조건, 필수 문구 통합
        function checkFoodTypePhrasesUnified() {
            const errors = [];
            const suggestions = [];
            const storageMethod = (checkedFields.storage_method || '').trim();
            const foodType      = (checkedFields.prdlst_dcnm || '').trim();
            const cautions      = (checkedFields.cautions || '').trim();
            const additional    = (checkedFields.additional_info || '').trim();

            // --- 신규 검증 로직 ---

            // 1. 냉동 조건 검증
            const isFrozenStorage = (() => {
                if (storageMethod.includes('냉동')) return true;
                const tempRegex = /(-?\d+(\.\d+)?)\s*(℃|도)/g;
                let match;
                while ((match = tempRegex.exec(storageMethod)) !== null) {
                    const tempValue = parseFloat(match[1]);
                    if (!isNaN(tempValue) && tempValue <= -18) {
                        return true; // -18도 이하 온도가 있으면 냉동으로 간주
                    }
                }
                return false;
            })();

            if (isFrozenStorage) {
                const hasRequiredFrozenKeywords = cautions.includes('해동') || cautions.includes('재냉동') || additional.includes('해동') || additional.includes('재냉동');
                if (!hasRequiredFrozenKeywords) {
                    errors.push('냉동 보관 제품은 주의사항 또는 기타표시사항에 "해동" 또는 "재냉동" 관련 문구를 포함해야 합니다.');
                }
            }

            // 2. 냉장 조건 검증
            const isRefrigeratedStorage = (() => {
                if (storageMethod.includes('냉장')) return true;
                const rangeRegex = /(\d+(\.\d+)?)\s*~\s*(\d+(\.\d+)?)\s*(℃|도)/g;
                let match;
                while ((match = rangeRegex.exec(storageMethod)) !== null) {
                    const startTemp = parseFloat(match[1]);
                    const endTemp = parseFloat(match[3]);
                    // 0~10도 범위 내의 온도이면 냉장으로 간주
                    if (!isNaN(startTemp) && !isNaN(endTemp) && startTemp >= 0 && endTemp <= 10) {
                        return true;
                    }
                }
                return false;
            })();

            if (isRefrigeratedStorage) {
                const combinedText = cautions + additional;
                // '개봉' 키워드와 ('냉장' 또는 '빨리' 또는 '빠른 시일') 키워드가 모두 있어야 통과
                const hasOpeningKeyword = combinedText.includes('개봉') || combinedText.includes('구매') || combinedText.includes('구입');
                const hasStorageKeyword = combinedText.includes('냉장') || combinedText.includes('섭취') || combinedText.includes('취식');

                if (!(hasOpeningKeyword && hasStorageKeyword)) {
                    errors.push('냉장 보관 제품은 주의사항 또는 기타표시사항에 "개봉/구매 후 냉장 보관 및 빠른 섭취/취식" 관련 문구를 포함해야 합니다.');
                }
            }

            // --- 이하 기존 로직 유지 ---

            // 즉석조리식품: 조리방법
            if (foodType.includes("즉석조리") || foodType.includes("즉석 식품")) {
                const hasCooking = cautions.includes("조리방법") || additional.includes("조리방법");
                if (!hasCooking) {
                    errors.push('즉석조리식품은 기타표시사항에 "조리방법"을 표시해야 합니다.');
                }
            }

            // 유제품: 지방함량/멸균방식/냉장보관(℃ 범위)
            const dairyKeywords = ["우유", "치즈", "발효유", "요구르트", "유제품"];
            const isDairy = dairyKeywords.some(keyword => foodType.includes(keyword));
            if (isDairy) {
                const hasFatRegex = /지방.*\(\s*%\s*\)/;
                const hasFat = hasFatRegex.test(cautions) || hasFatRegex.test(additional);
                if (!hasFat) {
                    errors.push('조건: 유제품 | 항목: 주의사항/기타표시사항 | 문구: "지방함량(%)"');
                }
                const hasSteril = /멸균/.test(cautions) || /멸균/.test(additional);
                if (!hasSteril) {
                    errors.push('조건: 유제품 | 항목: 주의사항/기타표시사항 | 문구: "멸균방식"');
                }
                if (!isRefrigeratedStorage) {
                    errors.push('조건: 유제품 | 항목: 보관방법/주의사항/기타표시사항 | 문구: "냉장보관(0~10℃)"');
                }
            }

            // 필수 문구 (REGULATIONS.food_type_phrases)
            let requiredPhrases = [];
            Object.keys(REGULATIONS.food_type_phrases).forEach(key => {
                if (foodType.includes(key)) {
                    requiredPhrases = requiredPhrases.concat(REGULATIONS.food_type_phrases[key]);
                }
            });
            // "해동 후 재냉동 금지"는 위에서 이미 처리하므로 중복 방지
            requiredPhrases = requiredPhrases.filter(phrase => phrase !== "해동 후 재냉동 금지");
            requiredPhrases.forEach(phrase => {
                if (!cautions.includes(phrase) && !additional.includes(phrase)) {
                    errors.push(`조건: 식품유형("${foodType}") | 항목: 주의사항/기타표시사항 | 문구: "${phrase}"`);
                }
            });

            // 1399 문구
            const reportPhrase = "부정·불량식품신고는 국번없이 1399";
            const hasReport = cautions.includes("1399") || additional.includes("1399");
            if (!hasReport) {
                errors.push('모든 식품에는 "부정불량식품신고는 국번없이 1399"를 표시해야 합니다.');
            }

            return { errors, suggestions };
        }

        // 4. 사용 금지 문구
        function checkForbiddenPhrases() {
            const errors = [];
            const suggestions = [];
            const FIELD_LABELS = {
                'prdlst_nm': '제품명',
                'ingredient_info': '특정성분 함량',
                'rawmtrl_nm_display': '원재료명',
                'cautions': '주의사항',
                'additional_info': '기타표시사항'
            };
            const fieldsToCheck = [
                'prdlst_nm', 'ingredient_info', 'rawmtrl_nm_display', 'cautions', 'additional_info'
            ];
            fieldsToCheck.forEach(field => {
                let value = (checkedFields[field] || '').toString();
                forbiddenPhrases.forEach(phrase => {
                    // "원재료명"에 "천연"이 포함된 경우, 에러/수정제안 및 사용조건 안내를 반드시 표시
                    if (value && value.match(new RegExp(phrase, 'i'))) {
                        if (field === 'rawmtrl_nm_display' && phrase === '천연') {
                            // 에러/수정제안 및 사용조건 안내
                            let msg = `<strong>"${FIELD_LABELS[field]}" 항목에 사용 금지 문구 "${phrase}"가 표시되어 있습니다.</strong>`;
                            let suggestion = `<strong style="color:#222;">"${FIELD_LABELS[field]}" 항목에 "${phrase}" 문구를 표시하려면 반드시 사용 조건에 맞게 표시하세요.</strong><br>` +
                                '<span style="color:#888;">사용 조건:<br>' +
                                '① 원료 중에 합성향료·합성착색료·방부제 등 어떠한 인공 화학 성분도 전혀 포함되어 있지 않아야 함<br>' +
                                '② 최소한의 물리적 가공(세척·절단·동결·건조 등)만 거친 상태여야 함<br>' +
                                '③ "천연"과 유사한 의미로 오인될 수 있는 "자연산(naturel)" 등의 외국어 사용도 동일 기준 적용<br>' +
                                '④ 식품유형별로 별도 금지 사항(「식품등의 표시기준」의 개별 고시 규정)이 있는 경우, 그 규정에 따라 추가 제한이 있음<br>' +
                                '⑤ 예: 설탕에는 "천연설탕"이라는 표현이 불가<br>' +
                                '⑥ 영업소 명칭 또는 등록상표에 포함된 경우는 허용<br>' +
                                '⑦ "천연향료" 등 고시된 허용 목록 내 용어만 예외적으로 허용</span>';
                            errors.push(`${msg}<br>${suggestion}`);
                            // value에서 "천연" 및 유사 영문 제거
                            value = value.replace(/천연/gi, '').replace(/natural/gi, '').replace(/naturel/gi, '');
                            checkedFields[field] = value.trim();
                            return;
                        }
                        // ...기존 자연 등 다른 문구 처리...
                        let msg = `<strong>"${FIELD_LABELS[field]}" 항목에 사용 금지 문구 "${phrase}"가 표시되어 있습니다.</strong>`;
                        let suggestion = `<strong style="color:#222;">"${FIELD_LABELS[field]}"에서 "${phrase}" 문구를 삭제하세요.</strong>`;
                        if (field === 'rawmtrl_nm_display' && phrase === '자연') {
                            suggestion = `<strong style="color:#222;">"${FIELD_LABELS[field]}" 항목에 "${phrase}" 문구를 표시하려면 반드시 사용 조건에 맞게 표시하세요.</strong><br>` +
                                '<span style="color:#888;">사용 조건:<br>' +
                                '① "자연"이라는 용어는 가공되지 않은 농산물·임산물·수산물·축산물에 대해서만 허용<br>' +
                                '② 수확하여 세척·포장만 거친 원물(raw agricultural/seafood/livestock products)에만 허용<br>' +
                                '③ 이미 "가공식품"으로 분류된 상태라면 "자연" 표기가 불가능<br>' +
                                '④ 유전자변형식품, 나노식품 등은 "자연" 표기가 금지됨<br>' +
                                '⑤ 영업소 명칭 또는 등록상표에 포함된 경우는 허용<br>' +
                                '⑥ 단, 제품명(product name) 자체에 "천연"·"자연"을 붙일 수는 없음</span>';
                        }
                        errors.push(`${msg}<br>${suggestion}`);
                    }
                });
            });
            return { errors, suggestions: [] };
        }

        // 분리배출마크 추천 함수
        function recommendRecyclingMarkByMaterial(packageMaterial) {
            const material = packageMaterial.toLowerCase();
            if (material.includes('무색페트') || material.includes('무색 페트')) return '무색페트';
            else if (material.includes('유색페트') || material.includes('유색 페트')) return '유색페트';
            else if (material.includes('pet') || material.includes('페트')) return '플라스틱(PET)';
            else if (material.includes('hdpe')) return '플라스틱(HDPE)';
            else if (material.includes('ldpe')) return '플라스틱(LDPE)';
            else if (material.includes('pp') || material.includes('폴리프로필렌')) return '플라스틱(PP)';
            else if (material.includes('ps') || material.includes('폴리스티렌')) return '플라스틱(PS)';
            else if (material.includes('기타') && material.includes('플라스틱')) return '기타플라스틱';
            else if (material.includes('종이') && !material.includes('팩')) return '종이';
            else if (material.includes('일반팩') || (material.includes('팩') && !material.includes('멸균'))) return '일반팩';
            else if (material.includes('멸균팩') || (material.includes('멸균') && material.includes('팩'))) return '멸균팩';
            else if (material.includes('철') || (material.includes('캔') && material.includes('철'))) return '캔류(철)';
            else if (material.includes('알미늄') || material.includes('알루미늄') || (material.includes('캔') && material.includes('알미늄'))) return '캔류(알미늄)';
            else if (material.includes('유리')) return '유리';
            else if (material.includes('복합재질') || material.includes('도포') || material.includes('첩합')) return '복합재질';
            else if (material.includes('비닐') && material.includes('pet')) return '비닐(PET)';
            else if (material.includes('비닐') && material.includes('hdpe')) return '비닐(HDPE)';
            else if (material.includes('비닐') && material.includes('ldpe')) return '비닐(LDPE)';
            else if (material.includes('비닐') && material.includes('pp')) return '비닐(PP)';
            else if (material.includes('비닐') && material.includes('ps')) return '비닐(PS)';
            else if (material.includes('비닐')) return '비닐(기타)';
            else return '';
        }

        // 5. 분리배출마크
        function checkRecyclingMarkCompliance() {
            const errors = [];
            const suggestions = [];
            const packageMaterial = (checkedFields.frmlc_mtrqlt || '').toLowerCase();
            const select = document.getElementById('recyclingMarkSelect');
            const selectedMark = select ? select.value : '';



            if (!packageMaterial) {
                errors.push('포장재질을 표시하세요.');
                return { errors, suggestions };
            }

            // 사용자가 마크를 선택하지 않았으면 검증하지 않음
            if (!selectedMark || selectedMark === '미표시') {
                return { errors, suggestions };
            }

            // 마크와 재질 키워드 간의 호환성 검증 헬퍼 함수
            const isCompatible = (mark, materialKeywords) => {
                return materialKeywords.some(keyword => packageMaterial.includes(keyword));
            };

            let compatible = false;
            switch (selectedMark) {
                case '무색페트':
                    compatible = isCompatible(selectedMark, ['pet', '페트', '무색']);
                    break;
                case '유색페트':
                    compatible = isCompatible(selectedMark, ['pet', '페트', '유색']);
                    break;
                case '플라스틱(PET)':
                    compatible = isCompatible(selectedMark, ['pet', '페트']);
                    break;
                case '플라스틱(LDPE)':
                    compatible = isCompatible(selectedMark, ['ldpe', '저밀도', '폴리에틸렌', 'pe']);
                    break;
                case '플라스틱(HDPE)':
                    compatible = isCompatible(selectedMark, ['hdpe', '고밀도', '폴리에틸렌', 'pe']);
                    break;
                case '플라스틱(PP)':
                    compatible = isCompatible(selectedMark, ['pp', '피피', '폴리프로필렌']);
                    break;
                case '플라스틱(PS)':
                    compatible = isCompatible(selectedMark, ['ps', '피에스', '폴리스티렌']);
                    break;
                case '기타플라스틱':
                    compatible = isCompatible(selectedMark, ['기타', '플라스틱', 'other']);
                    break;
                case '캔류(철)':
                    compatible = isCompatible(selectedMark, ['철', 'steel', '캔']);
                    break;
                case '캔류(알미늄)':
                    compatible = isCompatible(selectedMark, ['알미늄', '알루미늄', 'aluminum', 'al', '캔']);
                    break;
                case '종이':
                    compatible = isCompatible(selectedMark, ['종이', 'paper']) && !packageMaterial.includes('팩');
                    break;
                case '일반팩':
                    compatible = packageMaterial.includes('팩') && !packageMaterial.includes('멸균');
                    break;
                case '멸균팩':
                    compatible = packageMaterial.includes('멸균') && packageMaterial.includes('팩');
                    break;
                case '유리':
                    compatible = isCompatible(selectedMark, ['유리', 'glass']);
                    break;
                case '복합재질':
                    compatible = isCompatible(selectedMark, ['복합재질', '도포', '첩합', '코팅']);
                    break;
                case '비닐(PET)':
                    compatible = isCompatible(selectedMark, ['비닐', 'pet', '페트']);
                    break;
                case '비닐(HDPE)':
                    compatible = isCompatible(selectedMark, ['비닐', 'hdpe', '고밀도']);
                    break;
                case '비닐(LDPE)':
                    compatible = isCompatible(selectedMark, ['비닐', 'ldpe', '저밀도']);
                    break;
                case '비닐(PP)':
                    compatible = isCompatible(selectedMark, ['비닐', 'pp', '폴리프로필렌']);
                    break;
                case '비닐(PS)':
                    compatible = isCompatible(selectedMark, ['비닐', 'ps', '폴리스티렌']);
                    break;
                case '비닐(기타)':
                    compatible = isCompatible(selectedMark, ['비닐', '기타']);
                    break;
                default:
                    const recommendedMark = recommendRecyclingMarkByMaterial(packageMaterial);
                    compatible = (selectedMark === recommendedMark);
                    break;
            }


            
            if (!compatible) {
                errors.push(
                    `포장재질("${checkedFields.frmlc_mtrqlt}")과 분리배출마크("${selectedMark}")가 일치하지 않습니다. 사용된 포장재질과 분리배출마크를 재확인하세요.`
                );
            }

            return { errors, suggestions };
        }

        // 6. 소비기한
        function checkExpiryCompliance() {
            const errors = [];
            const suggestions = [];
            const foodType = (checkedFields.prdlst_dcnm || '').trim();
            const expiry = (checkedFields.pog_daycnt || '').trim();
            const storageMethod = (checkedFields.storage_method || '').trim();

            if (!expiry || !foodType) {
                return { errors, suggestions };
            }

            // 냉동식품 또는 장기보존식품(통조림, 레토르트)은 검증에서 제외
            const isFrozen = storageMethod.toLowerCase().includes('냉동') || foodType.toLowerCase().includes('냉동');
            const isLongTermStorage = foodType.includes('통조림') || foodType.includes('병조림') || foodType.includes('레토르트');

            if (isFrozen || isLongTermStorage) {
                return { errors, suggestions }; // 검증 대상이 아니므로 종료
            }

            // 1. 식품유형에 맞는 권장 소비기한 찾기
            const recommendationKeys = Object.keys(REGULATIONS.expiry_recommendation || {}).sort((a, b) => b.length - a.length);
            let recommendation = null;
            for (const key of recommendationKeys) {
                if (foodType.includes(key)) {
                    recommendation = REGULATIONS.expiry_recommendation[key];
                    break;
                }
            }

            if (!recommendation || typeof recommendation.shelf_life !== 'number') {
                return { errors, suggestions }; // 검증 대상이 아니면 종료
            }

            // 2. 입력된 소비기한을 '일' 단위로 변환
            let totalDays = 0;
            const yearMatch = expiry.match(/(\d+)\s*년/);
            const monthMatch = expiry.match(/(\d+)\s*개월/);
            const dayMatch = expiry.match(/(\d+)\s*일/);

            if (yearMatch) {
                totalDays = parseInt(yearMatch[1], 10) * 365;
            } else if (monthMatch) {
                totalDays = parseInt(monthMatch[1], 10) * 30;
            } else if (dayMatch) {
                totalDays = parseInt(dayMatch[1], 10);
            }

            if (totalDays === 0) {
                return { errors, suggestions }; // 유효한 기간이 아니면 종료
            }

            // 3. 권장 소비기한을 '일' 단위로 변환
            let recommendedDays = 0;
            if (recommendation.unit === 'months') {
                recommendedDays = recommendation.shelf_life * 30;
            } else if (recommendation.unit === 'days') {
                recommendedDays = recommendation.shelf_life;
            }

            // 4. 비교 및 오류 메시지 생성
            if (recommendedDays > 0 && totalDays > recommendedDays) {
                const unitText = recommendation.unit === 'months' ? '개월' : '일';
                const suggestionMsg = `권장 소비기한(${recommendation.shelf_life}${unitText})을 초과하였습니다. 설정 근거를 반드시 확인하시기 바랍니다.`;
                suggestions.push(suggestionMsg);
            }

            return { errors, suggestions };
        }
        
        function checkRecyclingMarkCompliance() { 
            const errors = [];
            const suggestions = [];
            
            // 분리배출마크 검사
            const frmlcMtrqlt = checkedFields.frmlc_mtrqlt || '';
            const container = document.getElementById('recyclingMarkContainer');
            
            if (frmlcMtrqlt) {
                if (!container) {
                    errors.push(`포장재질(${frmlcMtrqlt})에 대한 분리배출마크가 필요합니다.`);
                    
                    // 포장재질에 따른 추천 마크
                    if (frmlcMtrqlt.includes('종이')) {
                        suggestions.push("종이 분리배출마크 추가 필요");
                    } else if (frmlcMtrqlt.includes('페트') || frmlcMtrqlt.includes('PET')) {
                        suggestions.push("플라스틱(PET) 분리배출마크 추가 필요");
                    } else if (frmlcMtrqlt.includes('PP') || frmlcMtrqlt.includes('폴리프로필렌')) {
                        suggestions.push("플라스틱(PP) 분리배출마크 추가 필요");
                    } else if (frmlcMtrqlt.includes('유리')) {
                        suggestions.push("유리 분리배출마크 추가 필요");
                    } else if (frmlcMtrqlt.includes('복합재질')) {
                        suggestions.push("복합재질 분리배출마크 추가 필요");
                    }
                }
                
                // 복합재질 마크에 추가 설명이 있는지 확인
                if (container && frmlcMtrqlt.includes('복합재질')) {
                    const textContainer = container.querySelector('.recycling-mark-text');
                    if (!textContainer || !textContainer.textContent.trim()) {
                        errors.push("복합재질 분리배출마크에 재질 정보(예: 몸체(종이)/뚜껑(PP))를 추가해야 합니다.");
                    }
                }
            }
            
            return { errors, suggestions };
        }
        
        function checkExpiryCompliance() { 
            const errors = [];
            const suggestions = [];
            
            // 소비기한 검사
            const pogDaycnt = checkedFields.pog_daycnt || '';
            const foodType = checkedFields.prdlst_dcnm || '';
            
            if (pogDaycnt && foodType) {
                // REGULATIONS.expiry_recommendation에서 식품유형별 권장 소비기한 확인
                const recommendation = REGULATIONS.expiry_recommendation[foodType];
                
                if (recommendation) {
                    const { shelf_life, unit } = recommendation;
                    const recommendedMonths = parseInt(shelf_life);
                    
                    if (!isNaN(recommendedMonths)) {
                        // 권장 소비기한과 입력된 소비기한 비교
                        const currentMonthMatch = pogDaycnt.match(/(\d+)\s*개월/);
                        
                        if (currentMonthMatch) {
                            const currentMonths = parseInt(currentMonthMatch[1]);
                            
                            if (!isNaN(currentMonths) && currentMonths > recommendedMonths) {
                                suggestions.push(`현재 소비기한(${currentMonths}개월)이 ${foodType}의 권장 소비기한(${recommendedMonths}개월)보다 깁니다. 검토가 필요합니다.`);
                            }
                        }
                    }
                }
            }
            
            return { errors, suggestions };
        }
    
        function showValidationModal() {
            // 기존 모달과 오버레이 제거
            let modal = document.getElementById('validationModal');
            if (modal) modal.remove();
            
            // 혹시 남아있는 modal-backdrop 요소 제거
            const backdrops = document.querySelectorAll('.modal-backdrop');
            backdrops.forEach(backdrop => backdrop.remove());
            
            // 모달 생성
            modal = document.createElement('div');
            modal.id = 'validationModal';
            modal.className = 'modal fade';
            modal.innerHTML = `<div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">규정 검증 결과</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><table class="table table-bordered"><thead><tr><th>검증 항목</th><th>상태</th><th>결과 및 제안</th></tr></thead><tbody id="validationResultBody"></tbody></table></div></div></div>`;
            document.body.appendChild(modal);
            
            // 모달이 닫힐 때 오버레이 제거 이벤트 추가
            modal.addEventListener('hidden.bs.modal', function() {
                document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
            });
            
            new bootstrap.Modal(modal).show();
            return modal;
        }
    
        async function validateSettings() {
            // 기존 backdrop 제거
            document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
            
            // 검증 항목 순서 및 매핑
            const validationItems = [
                {
                    label: '표시면 면적',
                    check: () => {
                        const width = parseFloat(document.getElementById('widthInput').value) || 0;
                        const height = parseFloat(document.getElementById('heightInput').value) || 0;
                        const area = width * height;
                        return {
                            ok: area >= 40,
                            errors: area < 40 ? [
                                `<strong style="color:#222;">표시면 면적은 최소 40cm² 이상이어야 합니다 («식품 등의 표시기준» 제4조).</strong>`
                            ] : [],
                            suggestions: area < 40 ? [
                                `<strong style="color:#222;">면적을 40cm² 이상으로 조정하세요.</strong>`
                            ] : []
                        };
                    },
                    always: true
                },
                {
                    label: '글꼴 크기',
                    check: () => {
                        const fontSize = parseFloat(document.getElementById('fontSizeInput').value) || 10;
                        return {
                            ok: fontSize >= REGULATIONS.font_size.general.min,
                            errors: fontSize < REGULATIONS.font_size.general.min ? [
                                `<strong style="color:#222;">글꼴 크기는 최소 ${REGULATIONS.font_size.general.min}pt 이상이어야 합니다 («식품 등의 표시기준» 제6조).</strong>`
                            ] : [],
                            suggestions: fontSize < REGULATIONS.font_size.general.min ? [
                                `<strong style="color:#222;">글꼴 크기를 ${REGULATIONS.font_size.general.min}pt 이상으로 조정하세요.</strong>`
                            ] : []
                        };
                    },
                    always: true
                },
                {
                    label: '제품명 성분 표시',
                    check: () => {
                        const result = checkFarmSeafoodCompliance();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    }
                },
                {
                    label: '필수 문구',
                    check: () => {
                        const result = checkFoodTypePhrasesUnified();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    }
                },
                {
                    label: '사용금지 문구',
                    check: () => checkForbiddenPhrases()
                },
                {
                    label: '알레르기 중복 표시',
                    check: () => {
                        const result = checkAllergenDuplication();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    }
                },
                {
                    label: '분리배출마크',
                    check: () => {
                        const result = checkRecyclingMarkCompliance();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    },
                    always: true
                },
                {
                    label: '소비기한',
                    check: () => {
                        const result = checkExpiryCompliance();
                        result.errors = (result.errors || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        result.suggestions = (result.suggestions || []).map(e => `<strong style="color:#222;">${e}</strong>`);
                        return result;
                    }
                }
            ];

            const results = validationItems.map(item => item.check());
            
            const modal = showValidationModal();
            const tbody = modal.querySelector('#validationResultBody');
            tbody.innerHTML = '';

            let hasErrors = false;

            // tbody에 모든 검증 항목을 한 번에 추가 (tr을 누적해서 innerHTML로 할당)
            let rowsHtml = '';
            for (let i = 0; i < validationItems.length; i++) {
                const item = validationItems[i];
                const result = results[i];

                rowsHtml += `<tr>`;

                // 항목명
                rowsHtml += `<td>${item.label}</td>`;

                // 결과
                if (!result.errors || result.errors.length === 0) {
                    rowsHtml += `<td><span class="text-success">적합</span></td>`;
                } else {
                    rowsHtml += `<td><span class="text-danger">재검토</span></td>`;
                    hasErrors = true;
                }

                // 에러/수정제안
                let msg = '';
                if (result.errors && result.errors.length > 0) msg += result.errors.join('<br>');
                if (result.suggestions && result.suggestions.length > 0) {
                    if (msg) msg += ' | ';
                    msg += result.suggestions.join('<br>');
                }
                rowsHtml += `<td>${msg}</td>`;

                rowsHtml += `</tr>`;
            }
            tbody.innerHTML = rowsHtml;
        }
    
        async function exportToPDF() {
            try {
                previewContent.style.transform = 'scale(1)';
                const { jsPDF } = window.jspdf;
                const canvas = await html2canvas(previewContent, { scale: 3, useCORS: true });
                const imgData = canvas.toDataURL('image/png');
                const widthCm = parseFloat(widthInput.value);
                const heightCm = parseFloat(heightInput.value.replace(' cm', ''));
                const orientation = widthCm > heightCm ? 'l' : 'p';
                const pdf = new jsPDF(orientation, 'cm', [widthCm, heightCm]);
                pdf.addImage(imgData, 'PNG', 0, 0, widthCm, heightCm);
                const productName = checkedFields.prdlst_nm || 'label';
                const date = new Date().toISOString().slice(0,10).replace(/-/g,"");
                pdf.save(`한글표시사항_${productName}_${date}.pdf`);
            } catch (error) {
                console.error('PDF generation error:', error);
            } finally {
                updateZoom();
            }
        }

        // 현재 분리배출마크 정보 수집 (개선된 버전)
        function getCurrentRecyclingMarkInfo() {
            const markElement = document.getElementById('recyclingMarkContainer');
            if (!markElement) {
                return {
                    enabled: false,
                    type: null,
                    position_x: null,
                    position_y: null,
                    text: null
                };
            }

            const style = markElement.style;
            const imgElement = markElement.querySelector('#recyclingMarkImage');
            const textElements = markElement.querySelectorAll('.recycling-text-line'); // 정확한 텍스트 라인들만 선택
            
            // 이미지 src에서 파일명 추출
            let markType = null;
            if (imgElement && imgElement.src) {
                const srcParts = imgElement.src.split('/');
                const fileName = srcParts[srcParts.length - 1];
                markType = fileName.replace('.png', '');
            }
            
            // 복합재질 텍스트 수집 - 입력 필드 값을 우선으로 사용
            let combinedText = null;
            
            // 먼저 입력 필드에서 텍스트 확인 (이것이 정확한 사용자 입력)
            const textInput = document.getElementById('additionalRecyclingText');
            if (textInput && textInput.value.trim()) {
                combinedText = textInput.value.trim();

            }
            
            // 입력 필드에 값이 없을 때만 DOM에서 수집
            if (!combinedText) {

                
                if (textElements.length > 0) {
                    const textArray = Array.from(textElements).map(el => el.textContent.trim()).filter(text => text);

                    if (textArray.length > 0) {
                        combinedText = textArray.join('/');
                    }
                }
            }
            

            
            return {
                enabled: true,
                type: markType,
                position_x: style.left ? style.left.replace('px', '') : (style.right ? 'right:' + style.right.replace('px', '') : '0'),
                position_y: style.top ? style.top.replace('px', '') : '0',
                text: combinedText
            };
        }
        
        // 추천 마크 갱신
        function updateRecyclingMarkUI(packageText) {
            if (!packageText) return;
            
            const material = packageText.toLowerCase();
            let recommendedMark = '';
            
            // 다양한 재질에 따른 마크 추천
            if (material.includes('무색페트') || material.includes('무색 페트')) recommendedMark = '무색페트';
            else if (material.includes('유색페트') || material.includes('유색 페트')) recommendedMark = '유색페트';
            else if (material.includes('페트') || material.includes('pet')) recommendedMark = '플라스틱(PET)';
            else if (material.includes('hdpe') || material.includes('고밀도폴리에틸렌')) recommendedMark = '플라스틱(HDPE)';
            else if (material.includes('ldpe') || material.includes('저밀도폴리에틸렌')) recommendedMark = '플라스틱(LDPE)';
            else if (material.includes('pp') || material.includes('폴리프로필렌')) recommendedMark = '플라스틱(PP)';
            else if (material.includes('ps') || material.includes('폴리스티렌')) recommendedMark = '플라스틱(PS)';
            else if (material.includes('pvc') || material.includes('폴리염화비닐')) recommendedMark = '플라스틱(PVC)';
            else if (material.includes('플라스틱') && !material.includes('(')) recommendedMark = '기타플라스틱';
            else if (material.includes('종이팩') || material.includes('종이 팩')) recommendedMark = '종이팩';
            else if (material.includes('종이')) recommendedMark = '종이';
            else if (material.includes('알루미늄') || material.includes('알미늄')) recommendedMark = '알루미늄';
            else if (material.includes('철') && !material.includes('캔')) recommendedMark = '철';
            else if ((material.includes('캔') && material.includes('금속')) || material.includes('금속캔')) recommendedMark = '금속캔';
            else if (material.includes('유리')) recommendedMark = '유리';
            else if (material.includes('비닐')) recommendedMark = '비닐';
            else if (material.includes('/') || (material.match(/[가-힣]+\([가-힣]+\)/) && material.match(/[가-힣]+\([가-힣]+\)/g).length > 1)) recommendedMark = '복합재질';
            
            if (recommendedMark) {
                const select = document.getElementById('recyclingMarkSelect');
                const addBtn = document.getElementById('addRecyclingMarkBtn');
                if (select && addBtn && addBtn.textContent === '추가') {
                    select.value = recommendedMark;
                    setRecyclingMark(recommendedMark);
                    addBtn.textContent = '제거';
                    addBtn.classList.replace('btn-outline-primary', 'btn-danger');
                    
                    const selectedOption = select.options[select.selectedIndex];
                    const additionalInputBox = document.getElementById('additionalTextInputBox');
                    if (additionalInputBox && selectedOption.dataset.isComposite === 'true') {
                        additionalInputBox.style.display = 'block';
                        // 복합재질이면 자동 포커스
                        setTimeout(() => document.getElementById('additionalRecyclingText').focus(), 100);
                    }
                }
            }
        }

        // 설정 저장
        function savePreviewSettings() {

            
            // labelId 찾기 시도 1: input 필드에서
            const labelInput = document.querySelector('input[name="label_id"]');

            const labelId = labelInput?.value;

            
            // labelId 찾기 시도 2: URL에서
            let finalLabelId = labelId;
            if (!finalLabelId) {
                const urlParams = new URLSearchParams(window.location.search);
                finalLabelId = urlParams.get('label_id');

            }
            
            if (!finalLabelId) {
                console.error('label_id를 찾을 수 없습니다. input:', labelInput, 'URL params:', new URLSearchParams(window.location.search).toString());
                alert('라벨 ID를 찾을 수 없습니다. 페이지를 새로고침해주세요.');
                return;
            }
            


            // 분리배출마크 정보 수집

            const recyclingMarkInfo = getCurrentRecyclingMarkInfo();



            const data = {
                label_id: finalLabelId,
                layout: document.getElementById('layoutSelect')?.value || 'vertical',
                width: parseFloat(document.getElementById('widthInput')?.value) || 10,
                length: parseFloat(document.getElementById('heightInput')?.value) || 10,
                font: document.getElementById('fontFamilySelect')?.value || "'Noto Sans KR'",
                font_size: parseFloat(document.getElementById('fontSizeInput')?.value) || 10,
                letter_spacing: parseInt(document.getElementById('letterSpacingInput')?.value) || -5,
                line_spacing: parseFloat(document.getElementById('lineHeightInput')?.value) || 1.2,
                recycling_mark: recyclingMarkInfo
            };
            


            const csrfToken = getCookie('csrftoken') || document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';


            fetch('/label/save_preview_settings/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify(data)
            })
            .then(res => {

                return res.json();
            })
            .then(res => {

                if (res.success) {
                    // 성공 메시지 표시
                    const saveBtn = document.getElementById('saveSettingsBtn');
                    if (saveBtn) {
                        const originalText = saveBtn.textContent;
                        saveBtn.textContent = '저장완료';
                        saveBtn.classList.remove('btn-outline-success');
                        saveBtn.classList.add('btn-success');
                        saveBtn.disabled = false; // 버튼 활성화
                        
                        setTimeout(() => {
                            saveBtn.textContent = originalText;
                            saveBtn.classList.remove('btn-success');
                            saveBtn.classList.add('btn-outline-success');
                        }, 2000);
                    }
                } else {
                    alert('미리보기 설정 저장 실패: ' + (res.error || ''));
                    // 실패 시에도 버튼 복원
                    const saveBtn = document.getElementById('saveSettingsBtn');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.textContent = '설정 저장';
                    }
                }
            })
            .catch(err => {
                console.error('저장 에러:', err);
                alert('미리보기 설정 저장 에러: ' + err);
                // 에러 시에도 버튼 복원
                const saveBtn = document.getElementById('saveSettingsBtn');
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = '설정 저장';
                }
            });
        }
    
        // 분리배출마크 복원 (개선된 버전)
        function restoreRecyclingMark(markData) {
            if (!markData.type) return;
            
            // 분리배출마크 설정 (기존 setRecyclingMark 함수 활용)
            // markData.type에서 실제 값 찾기
            let markValue = markData.type;
            
            // recyclingMarkMap에서 해당 타입 찾기
            const foundEntry = Object.entries(recyclingMarkMap).find(([key, value]) => {
                const imageName = value.img.split('/').pop().replace('.png', '');
                return imageName === markData.type || key === markData.type;
            });
            
            if (foundEntry) {
                markValue = foundEntry[0];
                
                // 셀렉트 박스에서 해당 값 선택
                const selectElement = document.getElementById('recyclingMarkSelect');
                if (selectElement) {
                    selectElement.value = markValue;
                }
                
                // 분리배출마크 설정
                setRecyclingMark(markValue, false);
                
                // 버튼 텍스트를 "해제"로 변경
                setTimeout(() => {
                    const addBtn = document.getElementById('addRecyclingMarkBtn');
                    if (addBtn) {
                        addBtn.textContent = '해제';
                        addBtn.classList.remove('btn-outline-primary');
                        addBtn.classList.add('btn-danger');
                    }
                    
                    // 추가 텍스트 입력 박스도 표시
                    const additionalInputBox = document.getElementById('additionalTextInputBox');
                    if (additionalInputBox) {
                        additionalInputBox.style.display = 'block';
                    }
                }, 50);
                
                // 위치 설정 (약간의 딜레이 후)
                setTimeout(() => {
                    const markElement = document.getElementById('recyclingMarkContainer');
                    if (markElement) {
                        if (markData.position_x && markData.position_x.startsWith('right:')) {
                            markElement.style.right = markData.position_x.replace('right:', '') + 'px';
                            markElement.style.left = 'auto';
                        } else {
                            markElement.style.left = markData.position_x + 'px';
                            markElement.style.right = 'auto';
                        }
                        markElement.style.top = markData.position_y + 'px';
                    }
                    
                    // 복합재질 텍스트 설정
                    if (markData.text) {

                        
                        // 복합재질 입력 필드에 텍스트 설정 먼저
                        const textInput = document.getElementById('additionalRecyclingText');
                        if (textInput) {
                            textInput.value = markData.text;
                        }
                        
                        // 잘못된 형태의 데이터를 감지하고 정리
                        let cleanText = markData.text;
                        
                        // "몸체(종이)뚜껑(PE)/몸체(종이)/뚜껑(PE)" 같은 패턴을 감지
                        const parts = markData.text.split('/');
                        if (parts.length > 2) {
                            // 첫 번째 부분이 나머지 부분들의 조합인지 확인
                            const firstPart = parts[0];
                            const remainingParts = parts.slice(1);
                            const combinedRemaining = remainingParts.join('');
                            
                            if (firstPart === combinedRemaining) {
                                // 잘못된 데이터이므로 나머지 부분들만 사용
                                cleanText = remainingParts.join('/');

                                
                                // 입력 필드도 정리된 텍스트로 업데이트
                                if (textInput) {
                                    textInput.value = cleanText;
                                }
                            }
                        }
                        
                        // 정리된 텍스트로 분리하여 추가
                        const lines = cleanText.split('/');

                        
                        lines.forEach((line, index) => {
                            const trimmedLine = line.trim();

                            if (trimmedLine) {
                                addTextToRecyclingMark(trimmedLine);
                            }
                        });
                    }
                }, 100);
            } else {
                console.warn('분리배출마크 타입을 찾을 수 없음:', markData.type);
            }
        }

        // 저장된 미리보기 설정 로드
        function loadSavedPreviewSettings() {

            
            try {
                const settingsScript = document.getElementById('preview-settings-data');

                
                if (!settingsScript) {
                    console.warn('preview-settings-data 스크립트 요소를 찾을 수 없습니다.');
                    return;
                }
                
                const settingsText = settingsScript.textContent;

                
                if (!settingsText || settingsText.trim() === '{}') {

                    return;
                }
                
                const settings = JSON.parse(settingsText);

                
                // 기본 설정 복원
                if (settings.width) {
                    const widthInput = document.getElementById('widthInput');
                    if (widthInput) {
                        widthInput.value = settings.width;

                    }
                }
                
                if (settings.font_size) {
                    const fontSizeInput = document.getElementById('fontSizeInput');
                    if (fontSizeInput) {
                        fontSizeInput.value = settings.font_size;

                    }
                }
                
                if (settings.letter_spacing !== undefined) {
                    const letterSpacingInput = document.getElementById('letterSpacingInput');
                    if (letterSpacingInput) {
                        letterSpacingInput.value = settings.letter_spacing;

                    }
                }
                
                if (settings.line_spacing) {
                    const lineHeightInput = document.getElementById('lineHeightInput');
                    if (lineHeightInput) {
                        lineHeightInput.value = settings.line_spacing;

                    }
                }
                
                if (settings.font) {
                    const fontFamilySelect = document.getElementById('fontFamilySelect');
                    if (fontFamilySelect) {
                        fontFamilySelect.value = settings.font;

                    }
                }
                
                // 분리배출마크 설정 복원
                const recyclingMark = settings.recycling_mark;
                if (recyclingMark && recyclingMark.enabled && recyclingMark.type) {

                    setTimeout(() => {
                        restoreRecyclingMark(recyclingMark);
                    }, 1500);
                }
                
                // 설정 복원 후 스타일 업데이트
                setTimeout(() => {
                    if (typeof updatePreviewStyles === 'function') {
                        updatePreviewStyles();

                    }
                }, 100);
                
            } catch (error) {
                console.error('저장된 설정 로드 중 오류:', error);
            }
        }
    
        // --- EVENT LISTENERS & INITIALIZATION ---
        function setupEventListeners() {
            const inputs = ['widthInput', 'fontSizeInput', 'letterSpacingInput', 'lineHeightInput', 'fontFamilySelect'];
            inputs.forEach(id => {
                document.getElementById(id)?.addEventListener('input', debounce(updatePreviewStyles, 250));
            });
            document.getElementById('resetSettingsBtn')?.addEventListener('click', resetSettings);
            document.getElementById('validateButton')?.addEventListener('click', validateSettings);
            const saveBtn = document.getElementById('saveSettingsBtn');
            if (saveBtn) {

                saveBtn.addEventListener('click', function(e) {

                    e.preventDefault();
                    savePreviewSettings();
                });
            } else {
                console.error('설정 저장 버튼을 찾을 수 없음!');
            }
            document.getElementById('exportPdfBtn')?.addEventListener('click', exportToPDF);
            document.getElementById('zoomInBtn')?.addEventListener('click', () => { currentZoom = Math.min(2, currentZoom + 0.1); updateZoom(); });
            document.getElementById('zoomOutBtn')?.addEventListener('click', () => { currentZoom = Math.max(0.5, currentZoom - 0.1); updateZoom(); });
        }
    
        window.addEventListener('message', function(e) {
            if (e.data?.type === 'previewCheckedFields' && e.data.checked) {

                dataLoaded = true;
                checkedFields = e.data.checked;
                renderTable(checkedFields);
                const frmlc = checkedFields.frmlc_mtrqlt || '';
                updateRecyclingMarkUI(frmlc);
                
                // Update footer with received date
                const updateDateTime = e.data.update_datetime || new Date().toISOString().slice(0, 16).replace('T', ' ');
                const footerInfo = document.querySelector('.footer-text .creator-info');
                if (footerInfo) footerInfo.textContent = `[${updateDateTime}]`;
            }
        });
    
        // Initial calls
        if (tbody) {
            tbody.innerHTML = `<tr><td colspan="2" style="text-align:center; padding: 20px; color: #6c757d;">표시사항 데이터를 기다리는 중...</td></tr>`;
        }

        if (window.opener) {

            window.opener.postMessage({ type: 'requestPreviewData' }, '*');
        }

        setTimeout(() => {
            if (!dataLoaded) {

                const sampleData = { prdlst_nm: '샘플 제품', prdlst_dcnm: '과자', content_weight: '100g', frmlc_mtrqlt: '종이', pog_daycnt: '제조일로부터 12개월', rawmtrl_nm_display: '밀가루(밀:미국산), 설탕, 식물성유지', cautions: '이 제품은 우유, 대두를 사용한 제품과 같은 제조시설에서 제조하고 있습니다.', additional_info: '부정불량식품 신고는 국번없이 1399' };
                renderTable(sampleData);
                updateRecyclingMarkUI(sampleData.frmlc_mtrqlt);
            }
        }, 2000);

        // 페이지 언로드 시 현재 설정을 자동 저장 (세션 스토리지에만)
        window.addEventListener('beforeunload', function() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const labelId = urlParams.get('label_id');
                if (!labelId) return;
                
                const recyclingMarkInfo = getCurrentRecyclingMarkInfo();
                const currentSettings = {
                    label_id: labelId,
                    width: parseFloat(widthInput.value) || 9,
                    font: fontFamilySelect.value || 'Noto Sans KR',
                    font_size: parseFloat(fontSizeInput.value) || 9,
                    letter_spacing: parseInt(letterSpacingInput.value) || 0,
                    line_spacing: parseFloat(lineHeightInput.value) || 1.4,
                    recycling_mark: recyclingMarkInfo,
                    auto_saved: true,
                    timestamp: new Date().toISOString()
                };
                
                sessionStorage.setItem('labelPreviewSettings_' + labelId, JSON.stringify(currentSettings));

            } catch (e) {
                console.warn('설정 자동 저장 실패:', e);
            }
        });
        
        setupEventListeners();
        renderRecyclingMarkUI();
        updatePreviewStyles();
        
        // 저장된 설정 로드
        loadSavedPreviewSettings();
    });
  </script>
</body>
</html>

